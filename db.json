{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/maupassant/source/css/jquery.fancybox.css","path":"css/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1485232115658},{"_id":"themes/maupassant/LICENSE","hash":"019dc6a9aba02ae3aaabca45f39aecd6e8e7f1d8","modified":1485232115659},{"_id":"themes/maupassant/_config.yml","hash":"8c21341a2876c2a1c9807be5e2c724a4e39166e3","modified":1485232115659},{"_id":"themes/maupassant/README.md","hash":"75d8c42569809961953d1934de445418c00ab94c","modified":1485232115659},{"_id":"themes/maupassant/package.json","hash":"81fb4e2ac051ecfb9a93f37b28910291b939771a","modified":1485232115660},{"_id":"source/_posts/2016-12-25-日志.md","hash":"086314b62961855f74bea9c3a29670d1948509f5","modified":1485182155817},{"_id":"source/_posts/2016-12-26-日志.md","hash":"f906791db9c9a9110c989bbae84616cf43bdb2e4","modified":1485182155817},{"_id":"source/_posts/动态数据源路由容易掉进去的坑.md","hash":"3724cd8c94901c253dc21b63d47b0ae555192154","modified":1485260314998},{"_id":"source/_posts/2016-12-27-日志.md","hash":"6395066de0c8904d68e535c49223e1b91337f529","modified":1485182155818},{"_id":"source/_posts/2017-01-01-日志.md","hash":"1bd1694fa842e875c0141cb8bba2f58982327cd3","modified":1485182155818},{"_id":"source/_posts/TOMCAT假死分析.md","hash":"2cbaf8cbf90eb68c1cc338a590cc911704d90186","modified":1485182155818},{"_id":"themes/maupassant/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1485232115656},{"_id":"themes/maupassant/.git/config","hash":"776ed8041073d1bb2a234fa37a0d49bad1f0c5f4","modified":1485232115656},{"_id":"source/_posts/博客环境搭建.md","hash":"ba8344197f470b7b5756574495e2543df859ba26","modified":1485182155818},{"_id":"source/categories/index.md","hash":"47249b118a8cd9acf493d1eed704a4da3af3c30e","modified":1485186203368},{"_id":"source/tags/index.md","hash":"de7928ddeccdaa87270690567db4839419bf8a52","modified":1485186087170},{"_id":"themes/maupassant/.git/index","hash":"ed94e33861f5006f742e1fe031e571e48d17e9c1","modified":1485256048499},{"_id":"themes/maupassant/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1485232114825},{"_id":"themes/maupassant/.git/packed-refs","hash":"965458983a3bb3e282036aa5812345d6370fe31d","modified":1485232115655},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"5d3556a885e355a8c2da65ef3e7b3ee36a628bfa","modified":1485232115659},{"_id":"themes/maupassant/languages/en.yml","hash":"e13ab1a2d2f1edbe67b4c035fd4667cb6a31db8e","modified":1485232115659},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"58e1d04bcd1834fa9d2960e18e027abbbccbedc9","modified":1485232115659},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"b47906ec0abf867fb3e3360bc046b7afb68aee25","modified":1485232115659},{"_id":"themes/maupassant/languages/ko.yml","hash":"909a33e0befa6978e8e72157c6b415b48551ee31","modified":1485232115659},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"ebacfa5d0c14d603e0d505757adb24c0bbe5dd13","modified":1485232115659},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"56b65995c60e99dcebbf00168447fd225d28e5b2","modified":1485232115659},{"_id":"themes/maupassant/layout/archive.jade","hash":"0050c883b4f202add71c8664d65e6072179e7190","modified":1485232115659},{"_id":"themes/maupassant/layout/base-without-sidebar.jade","hash":"690fee04231b2e6721580516849f7b80cf42be94","modified":1485232115659},{"_id":"themes/maupassant/layout/base.jade","hash":"99259568f4cc21bd825772b4cb84be2b29b78fa5","modified":1485232115660},{"_id":"themes/maupassant/layout/index.jade","hash":"f842164f6cba007c1dfcd7fe7bba24736bc886a9","modified":1485232115660},{"_id":"themes/maupassant/layout/page.jade","hash":"8d70fd3b93f2c9087a9ea7ec538dcc1d413bea01","modified":1485232115660},{"_id":"themes/maupassant/layout/post.jade","hash":"9cf29fb0daed95935154ce0fa2b154df5a9b11b1","modified":1485232115660},{"_id":"themes/maupassant/layout/single-column.jade","hash":"c35fff4d9b331a41af5bc10f4278ec3d9da503db","modified":1485232115660},{"_id":"themes/maupassant/layout/timeline.jade","hash":"f03d8df63a188543cfe4e85e76194abe081411a1","modified":1485232115660},{"_id":"themes/maupassant/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1485232114826},{"_id":"themes/maupassant/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1485232114826},{"_id":"themes/maupassant/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1485232114826},{"_id":"themes/maupassant/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1485232114827},{"_id":"themes/maupassant/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1485232114825},{"_id":"themes/maupassant/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1485232114826},{"_id":"themes/maupassant/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1485232114827},{"_id":"themes/maupassant/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1485232114826},{"_id":"themes/maupassant/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1485232114826},{"_id":"themes/maupassant/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1485232114827},{"_id":"themes/maupassant/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1485232114826},{"_id":"themes/maupassant/.git/logs/HEAD","hash":"dc61c9dfa2b7d31480d7dfbf25b94773c4ccbd68","modified":1485232115656},{"_id":"themes/maupassant/layout/_partial/after_footer.jade","hash":"3dbcc9a9f0d6e55da191d3393c18bbfcfe99fa69","modified":1485232115659},{"_id":"themes/maupassant/layout/_partial/comments.jade","hash":"6c7f63ba04a4d28323ba31e79a4927f3d3fcc56e","modified":1485232115659},{"_id":"themes/maupassant/layout/_partial/footer.jade","hash":"aa020b794e697e8e9612530c97c6295efde469fe","modified":1485232115659},{"_id":"themes/maupassant/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1485232115659},{"_id":"themes/maupassant/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1485232115659},{"_id":"themes/maupassant/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1485232115659},{"_id":"themes/maupassant/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1485232115659},{"_id":"themes/maupassant/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1485232115659},{"_id":"themes/maupassant/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1485232115659},{"_id":"themes/maupassant/layout/_partial/totop.jade","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1485232115659},{"_id":"themes/maupassant/layout/_widget/category.jade","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1485232115659},{"_id":"themes/maupassant/layout/_widget/links.jade","hash":"f57a0c76d243882b2b77330132bdb43bc648948b","modified":1485232115659},{"_id":"themes/maupassant/layout/_widget/recent_comments.jade","hash":"e119c5afa85abc60d139e2da99b0bfcd7a6530f8","modified":1485232115659},{"_id":"themes/maupassant/layout/_widget/recent_posts.jade","hash":"19431336d724d2118e46da43683bce9063176541","modified":1485232115659},{"_id":"themes/maupassant/layout/_widget/search.jade","hash":"193546282908e499813534f86d27ef6e0a1357b3","modified":1485232115659},{"_id":"themes/maupassant/layout/_widget/tag.jade","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1485232115659},{"_id":"themes/maupassant/source/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1485232115660},{"_id":"themes/maupassant/source/css/style.scss","hash":"158f1ebecf7b994ffae5332a627465f6bf38113b","modified":1485232115660},{"_id":"themes/maupassant/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1485232115660},{"_id":"themes/maupassant/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1485232115661},{"_id":"themes/maupassant/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1485232115661},{"_id":"themes/maupassant/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1485232115661},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1485232115661},{"_id":"themes/maupassant/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1485232115661},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1485232115661},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1485232115661},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1485232115661},{"_id":"themes/maupassant/source/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1485232115661},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1485232115661},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1485232115661},{"_id":"themes/maupassant/.git/objects/pack/pack-75caa364d8078c39e32101665c0c6c94ab45492f.idx","hash":"6918c045c1d26cd82874029e879921a25e1f78fe","modified":1485232115654},{"_id":"themes/maupassant/.git/refs/heads/master","hash":"e7de97753d00149057ca0ae9ed395fd347042cbf","modified":1485232115656},{"_id":"themes/maupassant/.git/logs/refs/heads/master","hash":"dc61c9dfa2b7d31480d7dfbf25b94773c4ccbd68","modified":1485232115656},{"_id":"themes/maupassant/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1485232115656},{"_id":"themes/maupassant/.git/logs/refs/remotes/origin/HEAD","hash":"dc61c9dfa2b7d31480d7dfbf25b94773c4ccbd68","modified":1485232115656},{"_id":"themes/maupassant/.git/objects/pack/pack-75caa364d8078c39e32101665c0c6c94ab45492f.pack","hash":"6052695097aa1a2b32d539f20f4778a915177617","modified":1485232115653},{"_id":"public/tags/index.html","hash":"a7e981d17ede436f4d9ce30d3f84b318e4025526","modified":1485260322729},{"_id":"public/categories/index.html","hash":"db265288078d778297fdf0bf2d537b677e19c022","modified":1485260322734},{"_id":"public/2017/01/05/TOMCAT假死分析/index.html","hash":"9938ff60aaadff068dd566de7373105f4a345229","modified":1485260322735},{"_id":"public/2016/12/31/2017-01-01-日志/index.html","hash":"b6bbbc33f651c5c9fdb61733cb7e5ac7743255d8","modified":1485260322735},{"_id":"public/2016/12/27/2016-12-27-日志/index.html","hash":"f5db6aa7020c827d94cb7d57a7be492b0dcd34bc","modified":1485260322735},{"_id":"public/archives/index.html","hash":"2af7886ed6e0dc3da5ef76e8839b577ac1580c4b","modified":1485260322735},{"_id":"public/2016/12/26/博客环境搭建/index.html","hash":"8a218e14adcb2522ca9295a01d6b4b32b786691a","modified":1485260322735},{"_id":"public/2016/12/26/2016-12-26-日志/index.html","hash":"c1e4cca91d714536bc0d45609b50af8231e36cb6","modified":1485260322735},{"_id":"public/2016/12/25/2016-12-25-日志/index.html","hash":"2def0a7ec26e3157e0169fc5a737844e73506312","modified":1485260322735},{"_id":"public/archives/2016/index.html","hash":"4c403226a63daf720565731877a79fc684cabfab","modified":1485260322735},{"_id":"public/archives/2017/index.html","hash":"4b6b3a9d4d2e14bc213ea24fcc1fe042815c7b7d","modified":1485260322735},{"_id":"public/categories/日志/index.html","hash":"1bb49d151ee0906fd417694591d94b110633a30b","modified":1485260322735},{"_id":"public/archives/2016/12/index.html","hash":"4c403226a63daf720565731877a79fc684cabfab","modified":1485260322735},{"_id":"public/categories/CODE/index.html","hash":"6a9fb44dfd4c137e08fe93a283bfa23d4cf885ac","modified":1485260322735},{"_id":"public/archives/2017/01/index.html","hash":"4b6b3a9d4d2e14bc213ea24fcc1fe042815c7b7d","modified":1485260322736},{"_id":"public/categories/通用技术/index.html","hash":"ac9b49462f38a8dce2afd462821af30ffbddc40f","modified":1485260322736},{"_id":"public/tags/日志/index.html","hash":"2b895f2454debba2a2eed87029fa737e820b8acf","modified":1485260322736},{"_id":"public/tags/tomcat/index.html","hash":"ddfa6aa005081672b83d4debd7387a385ef1cc3a","modified":1485260322736},{"_id":"public/tags/dbcp/index.html","hash":"b51f2290cc51d0c8e05c50c176946de8223943b4","modified":1485260322736},{"_id":"public/categories/zjipst/index.html","hash":"bcdee69acf185903037b7b9b2d0f53b8afb0e87d","modified":1485260322740},{"_id":"public/tags/BUG/index.html","hash":"4cbb96a6c5dc43235681511c1e5505b5c7855b94","modified":1485260322740},{"_id":"public/tags/Spring/index.html","hash":"30360ccffcff426555972370aea3df0425411330","modified":1485260322740},{"_id":"public/tags/DynamicDataSourceRouting/index.html","hash":"9da97af12c0f180b8fa013fba72e92d1a2d83d18","modified":1485260322740},{"_id":"public/tags/hexo/index.html","hash":"746ba385f118a2b7807520a4f53c59b86903b33a","modified":1485260322740},{"_id":"public/tags/shadowsocks/index.html","hash":"793430505d9520bd80068e2c56ebc820ecbb236b","modified":1485260322740},{"_id":"public/tags/ubuntu/index.html","hash":"3d990a7e9e071540b78c76eec7aad8febc941b39","modified":1485260322740},{"_id":"public/index.html","hash":"e76cae246d3bfc8666f4011d2eaf3fcf2fc8bcab","modified":1485260322740},{"_id":"public/2017/01/23/动态数据源路由容易掉进去的坑/index.html","hash":"80e22a5a81269b21d7592257db481959a5161798","modified":1485260322740},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1485260322742},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1485260322742},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1485260322742},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1485260322742},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1485260322742},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1485260322742},{"_id":"public/css/jquery.fancybox.css","hash":"f42f761157f26244673eb2f4a9215c70956f80dc","modified":1485260322777},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1485260322777},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1485260322777},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1485260322777},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1485260322777},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1485260322777},{"_id":"public/js/share.js","hash":"f49776e0baa2b913ddc7a20db24b3edd469c8343","modified":1485260322777},{"_id":"public/css/style.css","hash":"2afb6e7e24abf81c8b7b7d472fb0bb9b9a1eac16","modified":1485260322777}],"Category":[{"name":"日志","_id":"ciybhnb9v0004e4ttd1sbedwd"},{"name":"zjipst","_id":"ciybhnbaa000fe4ttovpjzzxo"},{"name":"CODE","_id":"ciybhnbac000ke4ttg18lneas"},{"name":"通用技术","_id":"ciybhnbac000oe4tt1e2fc6ov"}],"Data":[],"Page":[{"title":"categories","date":"2017-01-23T02:42:52.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-01-23 10:42:52\ntype: \"categories\"\n---\n","updated":"2017-01-23T15:43:23.368Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ciybhnb9q0001e4ttq6oj93ta","content":"","excerpt":"","more":""},{"title":"Tagcloud","date":"2017-01-23T02:40:42.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: Tagcloud\ndate: 2017-01-23 10:40:42\ntype: \"tags\"\n---\n","updated":"2017-01-23T15:41:27.170Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ciybhnb9t0003e4ttnfk4bdwu","content":"","excerpt":"","more":""}],"Post":[{"title":"2016-12-25 日志","date":"2016-12-25T14:27:16.000Z","_content":"\n折腾了一天hexo+github,总算把大致的开发框架弄好了，以后大概能按照这个模式写博客了。\n唯一有点麻烦的就是需要在vm+ubuntu的环境下进行md文件的编写和编译，有点麻烦，考虑以后用ssh+脚本自动化编译的模式，这样就能在windows环境下直接写博客了。\n虽说在Ubuntu下写也不是不行，但是总觉得VM很卡。\n是不是计算机内存不够呢？毕竟只有8G，但是看了Windows的资源管理器，发现CPU和内存使用情况都很健康，那为什么切换到VM下的Ubuntu就会这么卡呢？\n说了一堆无聊的废话，sign。\n今天除了吃早餐都没出门，中午和晚餐分别吃的羊排和小龙虾，感觉特不好，又贵又难吃；而且还很腻。\n写到这里发现用的都是纯文本，MD的格式化字符都忘得一干二净，写完这篇文章后一定要回头看看语法。\n用了两天的华为P9，感觉还可以，但是没有我想象中那么惊艳。系统偶尔有点卡，当然这也可能是我的幻觉而已。最让我满意的是指纹解锁，不用每次都去输入解锁密码，很是方便。\n但缺点也很多，比如换个字体还要钱，真是想钱想疯了，菊花为就这么缺钱？\n另外本来想这两天去科技图书馆逛逛的，结果下雨了，未能成行。而且天气也开始变得很冷，明明是10℃，却冷的和零下一样，真是奇怪。\n对了，md文件怎么插入图片呢？单一的文本还是有点难看啊。\n以后要在这里多写点技术文章，充实一下自己。另外还要开始写读书笔记了，看了那么多书，如果不写点东西记录一下，简直和没看一样。\n曾经的我可是文艺青年。\n就写到这里吧。\n毕竟只是我的测试文章。\n看看编译以后怎么样。\n\n","source":"_posts/2016-12-25-日志.md","raw":"---\ntitle: 2016-12-25 日志\ndate: 2016-12-25 22:27:16\ntags:\ncategory:\n- 日志\n---\n\n折腾了一天hexo+github,总算把大致的开发框架弄好了，以后大概能按照这个模式写博客了。\n唯一有点麻烦的就是需要在vm+ubuntu的环境下进行md文件的编写和编译，有点麻烦，考虑以后用ssh+脚本自动化编译的模式，这样就能在windows环境下直接写博客了。\n虽说在Ubuntu下写也不是不行，但是总觉得VM很卡。\n是不是计算机内存不够呢？毕竟只有8G，但是看了Windows的资源管理器，发现CPU和内存使用情况都很健康，那为什么切换到VM下的Ubuntu就会这么卡呢？\n说了一堆无聊的废话，sign。\n今天除了吃早餐都没出门，中午和晚餐分别吃的羊排和小龙虾，感觉特不好，又贵又难吃；而且还很腻。\n写到这里发现用的都是纯文本，MD的格式化字符都忘得一干二净，写完这篇文章后一定要回头看看语法。\n用了两天的华为P9，感觉还可以，但是没有我想象中那么惊艳。系统偶尔有点卡，当然这也可能是我的幻觉而已。最让我满意的是指纹解锁，不用每次都去输入解锁密码，很是方便。\n但缺点也很多，比如换个字体还要钱，真是想钱想疯了，菊花为就这么缺钱？\n另外本来想这两天去科技图书馆逛逛的，结果下雨了，未能成行。而且天气也开始变得很冷，明明是10℃，却冷的和零下一样，真是奇怪。\n对了，md文件怎么插入图片呢？单一的文本还是有点难看啊。\n以后要在这里多写点技术文章，充实一下自己。另外还要开始写读书笔记了，看了那么多书，如果不写点东西记录一下，简直和没看一样。\n曾经的我可是文艺青年。\n就写到这里吧。\n毕竟只是我的测试文章。\n看看编译以后怎么样。\n\n","slug":"2016-12-25-日志","published":1,"updated":"2017-01-23T14:35:55.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciybhnb9n0000e4ttg87s70g3","content":"<p>折腾了一天hexo+github,总算把大致的开发框架弄好了，以后大概能按照这个模式写博客了。<br>唯一有点麻烦的就是需要在vm+ubuntu的环境下进行md文件的编写和编译，有点麻烦，考虑以后用ssh+脚本自动化编译的模式，这样就能在windows环境下直接写博客了。<br>虽说在Ubuntu下写也不是不行，但是总觉得VM很卡。<br>是不是计算机内存不够呢？毕竟只有8G，但是看了Windows的资源管理器，发现CPU和内存使用情况都很健康，那为什么切换到VM下的Ubuntu就会这么卡呢？<br>说了一堆无聊的废话，sign。<br>今天除了吃早餐都没出门，中午和晚餐分别吃的羊排和小龙虾，感觉特不好，又贵又难吃；而且还很腻。<br>写到这里发现用的都是纯文本，MD的格式化字符都忘得一干二净，写完这篇文章后一定要回头看看语法。<br>用了两天的华为P9，感觉还可以，但是没有我想象中那么惊艳。系统偶尔有点卡，当然这也可能是我的幻觉而已。最让我满意的是指纹解锁，不用每次都去输入解锁密码，很是方便。<br>但缺点也很多，比如换个字体还要钱，真是想钱想疯了，菊花为就这么缺钱？<br>另外本来想这两天去科技图书馆逛逛的，结果下雨了，未能成行。而且天气也开始变得很冷，明明是10℃，却冷的和零下一样，真是奇怪。<br>对了，md文件怎么插入图片呢？单一的文本还是有点难看啊。<br>以后要在这里多写点技术文章，充实一下自己。另外还要开始写读书笔记了，看了那么多书，如果不写点东西记录一下，简直和没看一样。<br>曾经的我可是文艺青年。<br>就写到这里吧。<br>毕竟只是我的测试文章。<br>看看编译以后怎么样。</p>\n","excerpt":"","more":"<p>折腾了一天hexo+github,总算把大致的开发框架弄好了，以后大概能按照这个模式写博客了。<br>唯一有点麻烦的就是需要在vm+ubuntu的环境下进行md文件的编写和编译，有点麻烦，考虑以后用ssh+脚本自动化编译的模式，这样就能在windows环境下直接写博客了。<br>虽说在Ubuntu下写也不是不行，但是总觉得VM很卡。<br>是不是计算机内存不够呢？毕竟只有8G，但是看了Windows的资源管理器，发现CPU和内存使用情况都很健康，那为什么切换到VM下的Ubuntu就会这么卡呢？<br>说了一堆无聊的废话，sign。<br>今天除了吃早餐都没出门，中午和晚餐分别吃的羊排和小龙虾，感觉特不好，又贵又难吃；而且还很腻。<br>写到这里发现用的都是纯文本，MD的格式化字符都忘得一干二净，写完这篇文章后一定要回头看看语法。<br>用了两天的华为P9，感觉还可以，但是没有我想象中那么惊艳。系统偶尔有点卡，当然这也可能是我的幻觉而已。最让我满意的是指纹解锁，不用每次都去输入解锁密码，很是方便。<br>但缺点也很多，比如换个字体还要钱，真是想钱想疯了，菊花为就这么缺钱？<br>另外本来想这两天去科技图书馆逛逛的，结果下雨了，未能成行。而且天气也开始变得很冷，明明是10℃，却冷的和零下一样，真是奇怪。<br>对了，md文件怎么插入图片呢？单一的文本还是有点难看啊。<br>以后要在这里多写点技术文章，充实一下自己。另外还要开始写读书笔记了，看了那么多书，如果不写点东西记录一下，简直和没看一样。<br>曾经的我可是文艺青年。<br>就写到这里吧。<br>毕竟只是我的测试文章。<br>看看编译以后怎么样。</p>\n"},{"title":"2016-12-26 日志","date":"2016-12-26T10:45:52.000Z","_content":"今天的状态很不好。暖气吹得我头疼。\n项目定位服务出了问题，一看日志发现上次写的代码有问题，没有切换到地市。真是无语，当一个人的注意力被另一件事物吸引，很容易忘记之前在做的事情。引以为戒吧。\n\n不过这次的问题和我的代码实际上没有任何关联，因为我加了防御措施，当账号密码不正确时会自动切换到之前在用的通用账号密码。所以这次出现的状况是第三方的服务商的锅，与公司无关。\n根据已有的资料来看，问题不在于内外网交互，而在于外网侧到电信运营商之间的这条通路出现了问题。而根据那家公司的实施说，电信在昨天就发现该第三方公司到电信的请求数突然变为0了。\n大胆猜测一下，有这样几种可能：\n+ 电信本身挂了。可能性不大。\n+ 电信提供给第三方公司的账号密码过期了，或者是域名变更等等。总的来说就是两家公司的服务都没有出现问题，而关键在于沟通的不协调。这种可能性不大。\n+ 第三方公司挂了。\n\n然而以上三种情况实际上都不太可能发生，因为这个定位服务实际上已经稳定运行了将近三年，应该没人会来改动代码或者配置。\n转换一下立场，站在第三方公司的角度来看，他也应该是根据内网交互出来的请求数据，向电信公司发出定位请求。而这个请求实际上没有到电信，他那边抛Socket time out异常。\n那么什么情况下会出现这种请求无法到达的情况呢？\n假设两者同处于互联网，那么这种情况是难以想象的，除非请求方式并非简单的HTTP请求。\n\n想半天也想不明白究竟是何种原因会导致如此奇妙的状况，继续跟踪吧，希望明天能修复好。毕竟直接面对用户的是我们。\n\n剩下的也没什么好说的，就是感觉到心情有些不好，看待事物的方式又开始变得很悲观。\n这样一样就感觉到自己是一个相当脆弱的人，而又考虑到这点的我变得更加对未来不抱希望了。\n真是一个恶性循环。\n其实产生这种情绪的原因不仅仅是自身的原因，或者说直接原因不仅仅是因为我的性格问题。也许还和我的社交关系太过单一有关，另外我的兴趣爱好也实在乏善可陈。\n前者，大概是因为我对“朋友”这一概念太过执着，对于这一标准太过严格，以至于有生以来也没有多少人能符合我对于这一概念的标准。\n举个例子来说，上周夜跑，跑到江边的塑胶跑道时，遇见了一个高中同学。这实在是很稀罕的事，那时我没戴眼镜，是他叫住的我。他一边看着我，一边回忆着我的名字。\n“哎，你看起来有点眼熟啊，是东中的吗？”\n这几年人的外貌变化还是有点大，虽然第一时间我没认出他来，不过潜意识里已经叫出了他的名字。\n看来我的记忆力实在不错，然而我们之间并不怎么熟，无非是高一那一年里是室友，但没怎么搭话。\n寒暄几句之后我开始了跑步。在那之后说是要联系，实际上我也没有丝毫动力。毕竟我怀疑到最后他也没想起我是谁，尽管我报了自己的名字。\n说到高中，至少在第一年，是最为难受的一年，没有朋友，因为那时候我有点目中无人。\n不过目中无人也是有理由的，因为那些家伙实在教我鄙视。我就没遇到过一个在品德上稍微无可指摘的家伙。\n后两年状况倒是好了一些，大概是因为我成绩好，不怎么用功就能排名前列吧。总是有人来向我请教问题，我总是一一解答，没有丝毫不耐。\n这其实对于一般人来说是不正常的，频繁来问我的大概有6-7人，正常人早就不耐烦，甚至破口大骂的，然而我基本上没什么特殊的情绪。\n一方面可能是因为在那段时间里，我极度渴望和其他人交流的缘故吧。\n然而总有人带着有色眼镜来看待我的行为，比如对某某有兴趣啦，喜欢上某某啦。甚至还有一个女生的闺蜜直截了当的当面对我，“你是不是喜欢XX？放弃吧，她对你不会产生兴趣的。”当时我的想法是惊愕，反问她为什么会这么想，而后我也没在意她说了什么，继续去看我的书了。然而后来一想，才发现莫名其妙被人看低了。\n这样一想，我后来也无非是带着小丑的面具与人交往而已，心想着与人为善就能过得好，然而其实并不会。其他人总是会觉得你这善心有些可疑，继而捏造出一个龌蹉的缘由，然后心安理得地践踏你的善行。仅此而已。\n然而想到这里，我的潜意识又会为了他们开脱。其中的一条理由便是：人的记忆是不可靠的。人总是看到自己想看到的，记住自己想记住的。所以我揣测的那些证据无非是我悲观情绪下变形了的记忆，实际情况并非是那样。\n\n这种说法实际上也有些道理，我无法反驳。然而如果有人问我高中那会儿是否有什么要好的朋友，我的脑海只会是一片空白。\n\n既然如此，再回忆一下大学生活吧。那四年来说，唯一的情感大概就是陌生的惶恐。\n感觉自己不属于这里，无法融入任何一个集体。无法专心于任何事，唯一幸福的时刻就是在图书馆抱着本书度过一个一个充满阳光的下午。这四年的社交生活甚至比高中还要压抑。高中时至少还有频繁的交流，那时候的社交大概具有某种强制性，然而一到了大学，我失去了与人交往的理由，于是便不在对人感兴趣，甚至对生活本身失去了兴趣。\n那时候对抗抑郁侵蚀的唯一方法就是晚上出去跑步，从寝室出发，一直沿着启真湖跑。\n那段漫长的生活教会了我一个道理，实际上抑郁不过是内啡肽过低而已。一切的情绪低落都可以用慢跑来解决。\n\n然而现在还是无聊，还是没有找到活着的信念和追求，真是遗憾。\n","source":"_posts/2016-12-26-日志.md","raw":"---\ntitle: 2016-12-26 日志\ndate: 2016-12-26 18:45:52\ntags:\n- 日志\ncategory:\n- 日志\n---\n今天的状态很不好。暖气吹得我头疼。\n项目定位服务出了问题，一看日志发现上次写的代码有问题，没有切换到地市。真是无语，当一个人的注意力被另一件事物吸引，很容易忘记之前在做的事情。引以为戒吧。\n\n不过这次的问题和我的代码实际上没有任何关联，因为我加了防御措施，当账号密码不正确时会自动切换到之前在用的通用账号密码。所以这次出现的状况是第三方的服务商的锅，与公司无关。\n根据已有的资料来看，问题不在于内外网交互，而在于外网侧到电信运营商之间的这条通路出现了问题。而根据那家公司的实施说，电信在昨天就发现该第三方公司到电信的请求数突然变为0了。\n大胆猜测一下，有这样几种可能：\n+ 电信本身挂了。可能性不大。\n+ 电信提供给第三方公司的账号密码过期了，或者是域名变更等等。总的来说就是两家公司的服务都没有出现问题，而关键在于沟通的不协调。这种可能性不大。\n+ 第三方公司挂了。\n\n然而以上三种情况实际上都不太可能发生，因为这个定位服务实际上已经稳定运行了将近三年，应该没人会来改动代码或者配置。\n转换一下立场，站在第三方公司的角度来看，他也应该是根据内网交互出来的请求数据，向电信公司发出定位请求。而这个请求实际上没有到电信，他那边抛Socket time out异常。\n那么什么情况下会出现这种请求无法到达的情况呢？\n假设两者同处于互联网，那么这种情况是难以想象的，除非请求方式并非简单的HTTP请求。\n\n想半天也想不明白究竟是何种原因会导致如此奇妙的状况，继续跟踪吧，希望明天能修复好。毕竟直接面对用户的是我们。\n\n剩下的也没什么好说的，就是感觉到心情有些不好，看待事物的方式又开始变得很悲观。\n这样一样就感觉到自己是一个相当脆弱的人，而又考虑到这点的我变得更加对未来不抱希望了。\n真是一个恶性循环。\n其实产生这种情绪的原因不仅仅是自身的原因，或者说直接原因不仅仅是因为我的性格问题。也许还和我的社交关系太过单一有关，另外我的兴趣爱好也实在乏善可陈。\n前者，大概是因为我对“朋友”这一概念太过执着，对于这一标准太过严格，以至于有生以来也没有多少人能符合我对于这一概念的标准。\n举个例子来说，上周夜跑，跑到江边的塑胶跑道时，遇见了一个高中同学。这实在是很稀罕的事，那时我没戴眼镜，是他叫住的我。他一边看着我，一边回忆着我的名字。\n“哎，你看起来有点眼熟啊，是东中的吗？”\n这几年人的外貌变化还是有点大，虽然第一时间我没认出他来，不过潜意识里已经叫出了他的名字。\n看来我的记忆力实在不错，然而我们之间并不怎么熟，无非是高一那一年里是室友，但没怎么搭话。\n寒暄几句之后我开始了跑步。在那之后说是要联系，实际上我也没有丝毫动力。毕竟我怀疑到最后他也没想起我是谁，尽管我报了自己的名字。\n说到高中，至少在第一年，是最为难受的一年，没有朋友，因为那时候我有点目中无人。\n不过目中无人也是有理由的，因为那些家伙实在教我鄙视。我就没遇到过一个在品德上稍微无可指摘的家伙。\n后两年状况倒是好了一些，大概是因为我成绩好，不怎么用功就能排名前列吧。总是有人来向我请教问题，我总是一一解答，没有丝毫不耐。\n这其实对于一般人来说是不正常的，频繁来问我的大概有6-7人，正常人早就不耐烦，甚至破口大骂的，然而我基本上没什么特殊的情绪。\n一方面可能是因为在那段时间里，我极度渴望和其他人交流的缘故吧。\n然而总有人带着有色眼镜来看待我的行为，比如对某某有兴趣啦，喜欢上某某啦。甚至还有一个女生的闺蜜直截了当的当面对我，“你是不是喜欢XX？放弃吧，她对你不会产生兴趣的。”当时我的想法是惊愕，反问她为什么会这么想，而后我也没在意她说了什么，继续去看我的书了。然而后来一想，才发现莫名其妙被人看低了。\n这样一想，我后来也无非是带着小丑的面具与人交往而已，心想着与人为善就能过得好，然而其实并不会。其他人总是会觉得你这善心有些可疑，继而捏造出一个龌蹉的缘由，然后心安理得地践踏你的善行。仅此而已。\n然而想到这里，我的潜意识又会为了他们开脱。其中的一条理由便是：人的记忆是不可靠的。人总是看到自己想看到的，记住自己想记住的。所以我揣测的那些证据无非是我悲观情绪下变形了的记忆，实际情况并非是那样。\n\n这种说法实际上也有些道理，我无法反驳。然而如果有人问我高中那会儿是否有什么要好的朋友，我的脑海只会是一片空白。\n\n既然如此，再回忆一下大学生活吧。那四年来说，唯一的情感大概就是陌生的惶恐。\n感觉自己不属于这里，无法融入任何一个集体。无法专心于任何事，唯一幸福的时刻就是在图书馆抱着本书度过一个一个充满阳光的下午。这四年的社交生活甚至比高中还要压抑。高中时至少还有频繁的交流，那时候的社交大概具有某种强制性，然而一到了大学，我失去了与人交往的理由，于是便不在对人感兴趣，甚至对生活本身失去了兴趣。\n那时候对抗抑郁侵蚀的唯一方法就是晚上出去跑步，从寝室出发，一直沿着启真湖跑。\n那段漫长的生活教会了我一个道理，实际上抑郁不过是内啡肽过低而已。一切的情绪低落都可以用慢跑来解决。\n\n然而现在还是无聊，还是没有找到活着的信念和追求，真是遗憾。\n","slug":"2016-12-26-日志","published":1,"updated":"2017-01-23T14:35:55.817Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciybhnb9r0002e4tt1etc5sp7","content":"<p>今天的状态很不好。暖气吹得我头疼。<br>项目定位服务出了问题，一看日志发现上次写的代码有问题，没有切换到地市。真是无语，当一个人的注意力被另一件事物吸引，很容易忘记之前在做的事情。引以为戒吧。</p>\n<p>不过这次的问题和我的代码实际上没有任何关联，因为我加了防御措施，当账号密码不正确时会自动切换到之前在用的通用账号密码。所以这次出现的状况是第三方的服务商的锅，与公司无关。<br>根据已有的资料来看，问题不在于内外网交互，而在于外网侧到电信运营商之间的这条通路出现了问题。而根据那家公司的实施说，电信在昨天就发现该第三方公司到电信的请求数突然变为0了。<br>大胆猜测一下，有这样几种可能：</p>\n<ul>\n<li>电信本身挂了。可能性不大。</li>\n<li>电信提供给第三方公司的账号密码过期了，或者是域名变更等等。总的来说就是两家公司的服务都没有出现问题，而关键在于沟通的不协调。这种可能性不大。</li>\n<li>第三方公司挂了。</li>\n</ul>\n<p>然而以上三种情况实际上都不太可能发生，因为这个定位服务实际上已经稳定运行了将近三年，应该没人会来改动代码或者配置。<br>转换一下立场，站在第三方公司的角度来看，他也应该是根据内网交互出来的请求数据，向电信公司发出定位请求。而这个请求实际上没有到电信，他那边抛Socket time out异常。<br>那么什么情况下会出现这种请求无法到达的情况呢？<br>假设两者同处于互联网，那么这种情况是难以想象的，除非请求方式并非简单的HTTP请求。</p>\n<p>想半天也想不明白究竟是何种原因会导致如此奇妙的状况，继续跟踪吧，希望明天能修复好。毕竟直接面对用户的是我们。</p>\n<p>剩下的也没什么好说的，就是感觉到心情有些不好，看待事物的方式又开始变得很悲观。<br>这样一样就感觉到自己是一个相当脆弱的人，而又考虑到这点的我变得更加对未来不抱希望了。<br>真是一个恶性循环。<br>其实产生这种情绪的原因不仅仅是自身的原因，或者说直接原因不仅仅是因为我的性格问题。也许还和我的社交关系太过单一有关，另外我的兴趣爱好也实在乏善可陈。<br>前者，大概是因为我对“朋友”这一概念太过执着，对于这一标准太过严格，以至于有生以来也没有多少人能符合我对于这一概念的标准。<br>举个例子来说，上周夜跑，跑到江边的塑胶跑道时，遇见了一个高中同学。这实在是很稀罕的事，那时我没戴眼镜，是他叫住的我。他一边看着我，一边回忆着我的名字。<br>“哎，你看起来有点眼熟啊，是东中的吗？”<br>这几年人的外貌变化还是有点大，虽然第一时间我没认出他来，不过潜意识里已经叫出了他的名字。<br>看来我的记忆力实在不错，然而我们之间并不怎么熟，无非是高一那一年里是室友，但没怎么搭话。<br>寒暄几句之后我开始了跑步。在那之后说是要联系，实际上我也没有丝毫动力。毕竟我怀疑到最后他也没想起我是谁，尽管我报了自己的名字。<br>说到高中，至少在第一年，是最为难受的一年，没有朋友，因为那时候我有点目中无人。<br>不过目中无人也是有理由的，因为那些家伙实在教我鄙视。我就没遇到过一个在品德上稍微无可指摘的家伙。<br>后两年状况倒是好了一些，大概是因为我成绩好，不怎么用功就能排名前列吧。总是有人来向我请教问题，我总是一一解答，没有丝毫不耐。<br>这其实对于一般人来说是不正常的，频繁来问我的大概有6-7人，正常人早就不耐烦，甚至破口大骂的，然而我基本上没什么特殊的情绪。<br>一方面可能是因为在那段时间里，我极度渴望和其他人交流的缘故吧。<br>然而总有人带着有色眼镜来看待我的行为，比如对某某有兴趣啦，喜欢上某某啦。甚至还有一个女生的闺蜜直截了当的当面对我，“你是不是喜欢XX？放弃吧，她对你不会产生兴趣的。”当时我的想法是惊愕，反问她为什么会这么想，而后我也没在意她说了什么，继续去看我的书了。然而后来一想，才发现莫名其妙被人看低了。<br>这样一想，我后来也无非是带着小丑的面具与人交往而已，心想着与人为善就能过得好，然而其实并不会。其他人总是会觉得你这善心有些可疑，继而捏造出一个龌蹉的缘由，然后心安理得地践踏你的善行。仅此而已。<br>然而想到这里，我的潜意识又会为了他们开脱。其中的一条理由便是：人的记忆是不可靠的。人总是看到自己想看到的，记住自己想记住的。所以我揣测的那些证据无非是我悲观情绪下变形了的记忆，实际情况并非是那样。</p>\n<p>这种说法实际上也有些道理，我无法反驳。然而如果有人问我高中那会儿是否有什么要好的朋友，我的脑海只会是一片空白。</p>\n<p>既然如此，再回忆一下大学生活吧。那四年来说，唯一的情感大概就是陌生的惶恐。<br>感觉自己不属于这里，无法融入任何一个集体。无法专心于任何事，唯一幸福的时刻就是在图书馆抱着本书度过一个一个充满阳光的下午。这四年的社交生活甚至比高中还要压抑。高中时至少还有频繁的交流，那时候的社交大概具有某种强制性，然而一到了大学，我失去了与人交往的理由，于是便不在对人感兴趣，甚至对生活本身失去了兴趣。<br>那时候对抗抑郁侵蚀的唯一方法就是晚上出去跑步，从寝室出发，一直沿着启真湖跑。<br>那段漫长的生活教会了我一个道理，实际上抑郁不过是内啡肽过低而已。一切的情绪低落都可以用慢跑来解决。</p>\n<p>然而现在还是无聊，还是没有找到活着的信念和追求，真是遗憾。</p>\n","excerpt":"","more":"<p>今天的状态很不好。暖气吹得我头疼。<br>项目定位服务出了问题，一看日志发现上次写的代码有问题，没有切换到地市。真是无语，当一个人的注意力被另一件事物吸引，很容易忘记之前在做的事情。引以为戒吧。</p>\n<p>不过这次的问题和我的代码实际上没有任何关联，因为我加了防御措施，当账号密码不正确时会自动切换到之前在用的通用账号密码。所以这次出现的状况是第三方的服务商的锅，与公司无关。<br>根据已有的资料来看，问题不在于内外网交互，而在于外网侧到电信运营商之间的这条通路出现了问题。而根据那家公司的实施说，电信在昨天就发现该第三方公司到电信的请求数突然变为0了。<br>大胆猜测一下，有这样几种可能：</p>\n<ul>\n<li>电信本身挂了。可能性不大。</li>\n<li>电信提供给第三方公司的账号密码过期了，或者是域名变更等等。总的来说就是两家公司的服务都没有出现问题，而关键在于沟通的不协调。这种可能性不大。</li>\n<li>第三方公司挂了。</li>\n</ul>\n<p>然而以上三种情况实际上都不太可能发生，因为这个定位服务实际上已经稳定运行了将近三年，应该没人会来改动代码或者配置。<br>转换一下立场，站在第三方公司的角度来看，他也应该是根据内网交互出来的请求数据，向电信公司发出定位请求。而这个请求实际上没有到电信，他那边抛Socket time out异常。<br>那么什么情况下会出现这种请求无法到达的情况呢？<br>假设两者同处于互联网，那么这种情况是难以想象的，除非请求方式并非简单的HTTP请求。</p>\n<p>想半天也想不明白究竟是何种原因会导致如此奇妙的状况，继续跟踪吧，希望明天能修复好。毕竟直接面对用户的是我们。</p>\n<p>剩下的也没什么好说的，就是感觉到心情有些不好，看待事物的方式又开始变得很悲观。<br>这样一样就感觉到自己是一个相当脆弱的人，而又考虑到这点的我变得更加对未来不抱希望了。<br>真是一个恶性循环。<br>其实产生这种情绪的原因不仅仅是自身的原因，或者说直接原因不仅仅是因为我的性格问题。也许还和我的社交关系太过单一有关，另外我的兴趣爱好也实在乏善可陈。<br>前者，大概是因为我对“朋友”这一概念太过执着，对于这一标准太过严格，以至于有生以来也没有多少人能符合我对于这一概念的标准。<br>举个例子来说，上周夜跑，跑到江边的塑胶跑道时，遇见了一个高中同学。这实在是很稀罕的事，那时我没戴眼镜，是他叫住的我。他一边看着我，一边回忆着我的名字。<br>“哎，你看起来有点眼熟啊，是东中的吗？”<br>这几年人的外貌变化还是有点大，虽然第一时间我没认出他来，不过潜意识里已经叫出了他的名字。<br>看来我的记忆力实在不错，然而我们之间并不怎么熟，无非是高一那一年里是室友，但没怎么搭话。<br>寒暄几句之后我开始了跑步。在那之后说是要联系，实际上我也没有丝毫动力。毕竟我怀疑到最后他也没想起我是谁，尽管我报了自己的名字。<br>说到高中，至少在第一年，是最为难受的一年，没有朋友，因为那时候我有点目中无人。<br>不过目中无人也是有理由的，因为那些家伙实在教我鄙视。我就没遇到过一个在品德上稍微无可指摘的家伙。<br>后两年状况倒是好了一些，大概是因为我成绩好，不怎么用功就能排名前列吧。总是有人来向我请教问题，我总是一一解答，没有丝毫不耐。<br>这其实对于一般人来说是不正常的，频繁来问我的大概有6-7人，正常人早就不耐烦，甚至破口大骂的，然而我基本上没什么特殊的情绪。<br>一方面可能是因为在那段时间里，我极度渴望和其他人交流的缘故吧。<br>然而总有人带着有色眼镜来看待我的行为，比如对某某有兴趣啦，喜欢上某某啦。甚至还有一个女生的闺蜜直截了当的当面对我，“你是不是喜欢XX？放弃吧，她对你不会产生兴趣的。”当时我的想法是惊愕，反问她为什么会这么想，而后我也没在意她说了什么，继续去看我的书了。然而后来一想，才发现莫名其妙被人看低了。<br>这样一想，我后来也无非是带着小丑的面具与人交往而已，心想着与人为善就能过得好，然而其实并不会。其他人总是会觉得你这善心有些可疑，继而捏造出一个龌蹉的缘由，然后心安理得地践踏你的善行。仅此而已。<br>然而想到这里，我的潜意识又会为了他们开脱。其中的一条理由便是：人的记忆是不可靠的。人总是看到自己想看到的，记住自己想记住的。所以我揣测的那些证据无非是我悲观情绪下变形了的记忆，实际情况并非是那样。</p>\n<p>这种说法实际上也有些道理，我无法反驳。然而如果有人问我高中那会儿是否有什么要好的朋友，我的脑海只会是一片空白。</p>\n<p>既然如此，再回忆一下大学生活吧。那四年来说，唯一的情感大概就是陌生的惶恐。<br>感觉自己不属于这里，无法融入任何一个集体。无法专心于任何事，唯一幸福的时刻就是在图书馆抱着本书度过一个一个充满阳光的下午。这四年的社交生活甚至比高中还要压抑。高中时至少还有频繁的交流，那时候的社交大概具有某种强制性，然而一到了大学，我失去了与人交往的理由，于是便不在对人感兴趣，甚至对生活本身失去了兴趣。<br>那时候对抗抑郁侵蚀的唯一方法就是晚上出去跑步，从寝室出发，一直沿着启真湖跑。<br>那段漫长的生活教会了我一个道理，实际上抑郁不过是内啡肽过低而已。一切的情绪低落都可以用慢跑来解决。</p>\n<p>然而现在还是无聊，还是没有找到活着的信念和追求，真是遗憾。</p>\n"},{"title":"动态数据源路由容易掉进去的坑","date":"2017-01-23T22:19:27.000Z","_content":"\n#### 场景\n\n由于业务要求需要在不同的生产库、查询库（查询库中又包含多个子查询库）之间动态切换，所以使用了Spring提供的动态数据源路由功能。\n这个功能的基本原理，是将具体的数据库和一个枚举类作为键值对，由Spring提供的DynamicDataSourceRouting进行管理，然后将作为key的枚举类保存在ThreadLocal中以保证线程独立。这样在业务需要时，可以动态的根据一些条件，比如用户所处的行政区划之类的变量，动态的改变当前数据源。\n\n一开始，只有生产库和查询库两个数据源之间进行切换，后来根据业务需求，需要分摊统计查询的压力，将查询库切分为11个地市的子查询库。\n看起来，没有任何问题，只是在切换数据源时，多了一层切换操作，然后奇怪的问题发生了：本来应该插入到生产库的数据，被随机地插入到了不同的子查询库中。\n\n#### 代码还原\n\n以下是精简之后的代码:\n\n```\n//生产库、查询库所对应的key\npublic enum DataSourceKind{\n    READ, WRITE\n}\n\n//各个查询库所对应的key\npublic enum ReadDataSourceKind{\n    NingBo, WenZhou, JiaXing, ShaoXing...//略\n}\n```\n\n```\n//持有ThreadLocal的类，提供对于线程独立变量的访问\npublic class DataSourceHolder{\n    private static final ThreadLocal<DataSourceKind> dataSource = new ThreadLocal<DataSourceKind>();\n\n    //获取当前数据源\n    public static DataSourceKind getDataSource(){ return dataSource.get();}\n    //设置当前数据源\n    public static void setDataSource(DataSourceKind kind){ dataSource.set(kind);}\n\n}\n\n//略过各个查询库的holder\n```\n\n```\n//继承Spring的动态数据源路由，复写获取数据源key方法\npublic class MyDynamicDataSourceRouting extends DynamicDataSourceRouting{\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        return DataSourceHolder.getDataSource();\n    }\n}\n\n//略过查询库的routing\n```\n\n具体的切换用到了SpringAOP，大致就是定义一个@DbReadOnly注解，然后当检测到有方法使用了该注解，就进行数据源的切换。\n具体的业务场景中，只有很少一部分统计分析的请求会使用查询库，并且所有的@DbReadOnly注解基本上都是在Controller层。\n第一步先切换到READ， 然后根据当前登录用户所处行政区划来进行查询库的切换，等到这个请求完成之后，再在finally中切换回默认的生产库来。\n\n```\npublic Object proceed(Proceed obj){\n    DataSourceHolder.setDataSource(DataSourceKind.READ);\n    User user = SessionUtils.getCurrentUser();    //获取当前登录的用户\n    String xzqh = user.getXzqh();\n    if(xzqh.equals(XzqhConsts.JinHua)){ ReadDataSourceHolder.setDataSource(ReadDataSourceKind.JinHua);}\n    else if(xzqh.equals(XzqhConsts.WenZhou){ ReadDataSourceHolder.setDataSource(ReadDataSourceKind.WenZhou);})\n    ....//略\n    \n    try{\n        return obj.proceed();\n    }catch(Exception e){\n        e.printStackTrace();\n    }finally{\n        DataSourceHolder.setDataSource(DataSourceKind.WRITE);    //重置为生产库\n    }\n\n}\n```\n\n#### 分析与提示\n\n有经验的老司机大概已经看出了问题所在， 数据之所以会写入到查询库的原因实在是很可笑。\n还没明白过来的兄弟可以先看看接下来的提示。\n\n对于这个问题，我一开始根本摸不着头脑，因为在我的理解中，就算有线程没有切换回生产库，这个线程也会因为请求结束而被结束。\n更何况涉及到查询库的那些请求根本不涉及INSERT操作。\n\n更何况怎么可能不切换回生产库呢？finally中的代码无论如何，就算抛运行时异常，也应该是会执行的啊？\n\n难道一个线程会被多个请求同时使用？或者ThreadLocal并不是真正的ThreadLocal?而是会在线程之间互相影响？\n\n最后绝望的我甚至还开始怀疑起枚举类是否是线程安全的。\n\n我也是被问题迷糊了头脑，实际上这个问题非常简单，我不过是在一堆错误的前提下做着无望的挣扎，而没有去怀疑自己所坚信的这些前提是否是成立的。\n\n我觉得当遇到一个看似匪夷所思，甚至毫无可能发生的异常时，需要有清醒的头脑，来反过来质疑看似坚固的前提。\n\n下面是两个小小的提示：\n+ 线程真的会因为请求结束而结束吗？\n+ 上面finally的代码真的必然后执行吗？\n\n#### 柳暗花明\n\n很遗憾，对于上面两个问题的答案，其实都是否定的。\n\n事实上，Tomcat存在一个线程池机制，对于完成了请求的线程，并不会立即释放，而是回收到线程池中；并且，很关键的一点是，tomcat并不会清空ThreadLocal变量。\n\n第二个问题，非常可笑的，虽然finally的确必然会执行，然而这是有条件的：如果程序在try代码块之外抛了异常，那么finally将不会被执行。\n\n至此，一切谜题的答案已经展现在眼前。\n\n用户的session丢失，会导致获取xzqh那一行代码抛空指针异常，然而之前已经切换为READ库，所以当前线程已经指向了查询库，又因为抛运行时异常，所以请求结束；\n接着，线程被回收，进入线程池；过了不知道多久，有一个倒霉的请求被分配到了这个线程上执行，然后因为数据源并不会切换到WRITE中，所以INSERT操作会进入到查询库。\n\n#### 总结\n\n看似不可思议的问题， 既然真真切切的发生了，那么必然又一个合乎逻辑的解释；看似不可思议，不过是因为你误解了某些前提。\n另外我这么久也没看出问题所在，仅仅是以为我基础不够，否则如果我早知道tomcat有这么玄妙的线程池机制，那么我应该很快就能想到问题的关键点所在。\n\n不过，总的来说，这是一场很有趣的解谜体验。：）\n\n","source":"_posts/动态数据源路由容易掉进去的坑.md","raw":"---\ntitle: 动态数据源路由容易掉进去的坑\ndate: 2017-01-24 06:19:27\ntags:\n- BUG\n- Spring\n- DynamicDataSourceRouting\ncategory:\n- zjipst\n---\n\n#### 场景\n\n由于业务要求需要在不同的生产库、查询库（查询库中又包含多个子查询库）之间动态切换，所以使用了Spring提供的动态数据源路由功能。\n这个功能的基本原理，是将具体的数据库和一个枚举类作为键值对，由Spring提供的DynamicDataSourceRouting进行管理，然后将作为key的枚举类保存在ThreadLocal中以保证线程独立。这样在业务需要时，可以动态的根据一些条件，比如用户所处的行政区划之类的变量，动态的改变当前数据源。\n\n一开始，只有生产库和查询库两个数据源之间进行切换，后来根据业务需求，需要分摊统计查询的压力，将查询库切分为11个地市的子查询库。\n看起来，没有任何问题，只是在切换数据源时，多了一层切换操作，然后奇怪的问题发生了：本来应该插入到生产库的数据，被随机地插入到了不同的子查询库中。\n\n#### 代码还原\n\n以下是精简之后的代码:\n\n```\n//生产库、查询库所对应的key\npublic enum DataSourceKind{\n    READ, WRITE\n}\n\n//各个查询库所对应的key\npublic enum ReadDataSourceKind{\n    NingBo, WenZhou, JiaXing, ShaoXing...//略\n}\n```\n\n```\n//持有ThreadLocal的类，提供对于线程独立变量的访问\npublic class DataSourceHolder{\n    private static final ThreadLocal<DataSourceKind> dataSource = new ThreadLocal<DataSourceKind>();\n\n    //获取当前数据源\n    public static DataSourceKind getDataSource(){ return dataSource.get();}\n    //设置当前数据源\n    public static void setDataSource(DataSourceKind kind){ dataSource.set(kind);}\n\n}\n\n//略过各个查询库的holder\n```\n\n```\n//继承Spring的动态数据源路由，复写获取数据源key方法\npublic class MyDynamicDataSourceRouting extends DynamicDataSourceRouting{\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        return DataSourceHolder.getDataSource();\n    }\n}\n\n//略过查询库的routing\n```\n\n具体的切换用到了SpringAOP，大致就是定义一个@DbReadOnly注解，然后当检测到有方法使用了该注解，就进行数据源的切换。\n具体的业务场景中，只有很少一部分统计分析的请求会使用查询库，并且所有的@DbReadOnly注解基本上都是在Controller层。\n第一步先切换到READ， 然后根据当前登录用户所处行政区划来进行查询库的切换，等到这个请求完成之后，再在finally中切换回默认的生产库来。\n\n```\npublic Object proceed(Proceed obj){\n    DataSourceHolder.setDataSource(DataSourceKind.READ);\n    User user = SessionUtils.getCurrentUser();    //获取当前登录的用户\n    String xzqh = user.getXzqh();\n    if(xzqh.equals(XzqhConsts.JinHua)){ ReadDataSourceHolder.setDataSource(ReadDataSourceKind.JinHua);}\n    else if(xzqh.equals(XzqhConsts.WenZhou){ ReadDataSourceHolder.setDataSource(ReadDataSourceKind.WenZhou);})\n    ....//略\n    \n    try{\n        return obj.proceed();\n    }catch(Exception e){\n        e.printStackTrace();\n    }finally{\n        DataSourceHolder.setDataSource(DataSourceKind.WRITE);    //重置为生产库\n    }\n\n}\n```\n\n#### 分析与提示\n\n有经验的老司机大概已经看出了问题所在， 数据之所以会写入到查询库的原因实在是很可笑。\n还没明白过来的兄弟可以先看看接下来的提示。\n\n对于这个问题，我一开始根本摸不着头脑，因为在我的理解中，就算有线程没有切换回生产库，这个线程也会因为请求结束而被结束。\n更何况涉及到查询库的那些请求根本不涉及INSERT操作。\n\n更何况怎么可能不切换回生产库呢？finally中的代码无论如何，就算抛运行时异常，也应该是会执行的啊？\n\n难道一个线程会被多个请求同时使用？或者ThreadLocal并不是真正的ThreadLocal?而是会在线程之间互相影响？\n\n最后绝望的我甚至还开始怀疑起枚举类是否是线程安全的。\n\n我也是被问题迷糊了头脑，实际上这个问题非常简单，我不过是在一堆错误的前提下做着无望的挣扎，而没有去怀疑自己所坚信的这些前提是否是成立的。\n\n我觉得当遇到一个看似匪夷所思，甚至毫无可能发生的异常时，需要有清醒的头脑，来反过来质疑看似坚固的前提。\n\n下面是两个小小的提示：\n+ 线程真的会因为请求结束而结束吗？\n+ 上面finally的代码真的必然后执行吗？\n\n#### 柳暗花明\n\n很遗憾，对于上面两个问题的答案，其实都是否定的。\n\n事实上，Tomcat存在一个线程池机制，对于完成了请求的线程，并不会立即释放，而是回收到线程池中；并且，很关键的一点是，tomcat并不会清空ThreadLocal变量。\n\n第二个问题，非常可笑的，虽然finally的确必然会执行，然而这是有条件的：如果程序在try代码块之外抛了异常，那么finally将不会被执行。\n\n至此，一切谜题的答案已经展现在眼前。\n\n用户的session丢失，会导致获取xzqh那一行代码抛空指针异常，然而之前已经切换为READ库，所以当前线程已经指向了查询库，又因为抛运行时异常，所以请求结束；\n接着，线程被回收，进入线程池；过了不知道多久，有一个倒霉的请求被分配到了这个线程上执行，然后因为数据源并不会切换到WRITE中，所以INSERT操作会进入到查询库。\n\n#### 总结\n\n看似不可思议的问题， 既然真真切切的发生了，那么必然又一个合乎逻辑的解释；看似不可思议，不过是因为你误解了某些前提。\n另外我这么久也没看出问题所在，仅仅是以为我基础不够，否则如果我早知道tomcat有这么玄妙的线程池机制，那么我应该很快就能想到问题的关键点所在。\n\n不过，总的来说，这是一场很有趣的解谜体验。：）\n\n","slug":"动态数据源路由容易掉进去的坑","published":1,"updated":"2017-01-24T12:18:34.998Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciybhnba00005e4tt6j6gw3hn","content":"<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>由于业务要求需要在不同的生产库、查询库（查询库中又包含多个子查询库）之间动态切换，所以使用了Spring提供的动态数据源路由功能。<br>这个功能的基本原理，是将具体的数据库和一个枚举类作为键值对，由Spring提供的DynamicDataSourceRouting进行管理，然后将作为key的枚举类保存在ThreadLocal中以保证线程独立。这样在业务需要时，可以动态的根据一些条件，比如用户所处的行政区划之类的变量，动态的改变当前数据源。</p>\n<p>一开始，只有生产库和查询库两个数据源之间进行切换，后来根据业务需求，需要分摊统计查询的压力，将查询库切分为11个地市的子查询库。<br>看起来，没有任何问题，只是在切换数据源时，多了一层切换操作，然后奇怪的问题发生了：本来应该插入到生产库的数据，被随机地插入到了不同的子查询库中。</p>\n<h4 id=\"代码还原\"><a href=\"#代码还原\" class=\"headerlink\" title=\"代码还原\"></a>代码还原</h4><p>以下是精简之后的代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//生产库、查询库所对应的key</div><div class=\"line\">public enum DataSourceKind&#123;</div><div class=\"line\">    READ, WRITE</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//各个查询库所对应的key</div><div class=\"line\">public enum ReadDataSourceKind&#123;</div><div class=\"line\">    NingBo, WenZhou, JiaXing, ShaoXing...//略</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//持有ThreadLocal的类，提供对于线程独立变量的访问</div><div class=\"line\">public class DataSourceHolder&#123;</div><div class=\"line\">    private static final ThreadLocal&lt;DataSourceKind&gt; dataSource = new ThreadLocal&lt;DataSourceKind&gt;();</div><div class=\"line\"></div><div class=\"line\">    //获取当前数据源</div><div class=\"line\">    public static DataSourceKind getDataSource()&#123; return dataSource.get();&#125;</div><div class=\"line\">    //设置当前数据源</div><div class=\"line\">    public static void setDataSource(DataSourceKind kind)&#123; dataSource.set(kind);&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//略过各个查询库的holder</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//继承Spring的动态数据源路由，复写获取数据源key方法</div><div class=\"line\">public class MyDynamicDataSourceRouting extends DynamicDataSourceRouting&#123;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected Object determineCurrentLookupKey() &#123;</div><div class=\"line\">        return DataSourceHolder.getDataSource();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//略过查询库的routing</div></pre></td></tr></table></figure>\n<p>具体的切换用到了SpringAOP，大致就是定义一个@DbReadOnly注解，然后当检测到有方法使用了该注解，就进行数据源的切换。<br>具体的业务场景中，只有很少一部分统计分析的请求会使用查询库，并且所有的@DbReadOnly注解基本上都是在Controller层。<br>第一步先切换到READ， 然后根据当前登录用户所处行政区划来进行查询库的切换，等到这个请求完成之后，再在finally中切换回默认的生产库来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Object proceed(Proceed obj)&#123;</div><div class=\"line\">    DataSourceHolder.setDataSource(DataSourceKind.READ);</div><div class=\"line\">    User user = SessionUtils.getCurrentUser();    //获取当前登录的用户</div><div class=\"line\">    String xzqh = user.getXzqh();</div><div class=\"line\">    if(xzqh.equals(XzqhConsts.JinHua))&#123; ReadDataSourceHolder.setDataSource(ReadDataSourceKind.JinHua);&#125;</div><div class=\"line\">    else if(xzqh.equals(XzqhConsts.WenZhou)&#123; ReadDataSourceHolder.setDataSource(ReadDataSourceKind.WenZhou);&#125;)</div><div class=\"line\">    ....//略</div><div class=\"line\">    </div><div class=\"line\">    try&#123;</div><div class=\"line\">        return obj.proceed();</div><div class=\"line\">    &#125;catch(Exception e)&#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">    &#125;finally&#123;</div><div class=\"line\">        DataSourceHolder.setDataSource(DataSourceKind.WRITE);    //重置为生产库</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"分析与提示\"><a href=\"#分析与提示\" class=\"headerlink\" title=\"分析与提示\"></a>分析与提示</h4><p>有经验的老司机大概已经看出了问题所在， 数据之所以会写入到查询库的原因实在是很可笑。<br>还没明白过来的兄弟可以先看看接下来的提示。</p>\n<p>对于这个问题，我一开始根本摸不着头脑，因为在我的理解中，就算有线程没有切换回生产库，这个线程也会因为请求结束而被结束。<br>更何况涉及到查询库的那些请求根本不涉及INSERT操作。</p>\n<p>更何况怎么可能不切换回生产库呢？finally中的代码无论如何，就算抛运行时异常，也应该是会执行的啊？</p>\n<p>难道一个线程会被多个请求同时使用？或者ThreadLocal并不是真正的ThreadLocal?而是会在线程之间互相影响？</p>\n<p>最后绝望的我甚至还开始怀疑起枚举类是否是线程安全的。</p>\n<p>我也是被问题迷糊了头脑，实际上这个问题非常简单，我不过是在一堆错误的前提下做着无望的挣扎，而没有去怀疑自己所坚信的这些前提是否是成立的。</p>\n<p>我觉得当遇到一个看似匪夷所思，甚至毫无可能发生的异常时，需要有清醒的头脑，来反过来质疑看似坚固的前提。</p>\n<p>下面是两个小小的提示：</p>\n<ul>\n<li>线程真的会因为请求结束而结束吗？</li>\n<li>上面finally的代码真的必然后执行吗？</li>\n</ul>\n<h4 id=\"柳暗花明\"><a href=\"#柳暗花明\" class=\"headerlink\" title=\"柳暗花明\"></a>柳暗花明</h4><p>很遗憾，对于上面两个问题的答案，其实都是否定的。</p>\n<p>事实上，Tomcat存在一个线程池机制，对于完成了请求的线程，并不会立即释放，而是回收到线程池中；并且，很关键的一点是，tomcat并不会清空ThreadLocal变量。</p>\n<p>第二个问题，非常可笑的，虽然finally的确必然会执行，然而这是有条件的：如果程序在try代码块之外抛了异常，那么finally将不会被执行。</p>\n<p>至此，一切谜题的答案已经展现在眼前。</p>\n<p>用户的session丢失，会导致获取xzqh那一行代码抛空指针异常，然而之前已经切换为READ库，所以当前线程已经指向了查询库，又因为抛运行时异常，所以请求结束；<br>接着，线程被回收，进入线程池；过了不知道多久，有一个倒霉的请求被分配到了这个线程上执行，然后因为数据源并不会切换到WRITE中，所以INSERT操作会进入到查询库。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>看似不可思议的问题， 既然真真切切的发生了，那么必然又一个合乎逻辑的解释；看似不可思议，不过是因为你误解了某些前提。<br>另外我这么久也没看出问题所在，仅仅是以为我基础不够，否则如果我早知道tomcat有这么玄妙的线程池机制，那么我应该很快就能想到问题的关键点所在。</p>\n<p>不过，总的来说，这是一场很有趣的解谜体验。：）</p>\n","excerpt":"","more":"<h4 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h4><p>由于业务要求需要在不同的生产库、查询库（查询库中又包含多个子查询库）之间动态切换，所以使用了Spring提供的动态数据源路由功能。<br>这个功能的基本原理，是将具体的数据库和一个枚举类作为键值对，由Spring提供的DynamicDataSourceRouting进行管理，然后将作为key的枚举类保存在ThreadLocal中以保证线程独立。这样在业务需要时，可以动态的根据一些条件，比如用户所处的行政区划之类的变量，动态的改变当前数据源。</p>\n<p>一开始，只有生产库和查询库两个数据源之间进行切换，后来根据业务需求，需要分摊统计查询的压力，将查询库切分为11个地市的子查询库。<br>看起来，没有任何问题，只是在切换数据源时，多了一层切换操作，然后奇怪的问题发生了：本来应该插入到生产库的数据，被随机地插入到了不同的子查询库中。</p>\n<h4 id=\"代码还原\"><a href=\"#代码还原\" class=\"headerlink\" title=\"代码还原\"></a>代码还原</h4><p>以下是精简之后的代码:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">//生产库、查询库所对应的key</div><div class=\"line\">public enum DataSourceKind&#123;</div><div class=\"line\">    READ, WRITE</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//各个查询库所对应的key</div><div class=\"line\">public enum ReadDataSourceKind&#123;</div><div class=\"line\">    NingBo, WenZhou, JiaXing, ShaoXing...//略</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">//持有ThreadLocal的类，提供对于线程独立变量的访问</div><div class=\"line\">public class DataSourceHolder&#123;</div><div class=\"line\">    private static final ThreadLocal&lt;DataSourceKind&gt; dataSource = new ThreadLocal&lt;DataSourceKind&gt;();</div><div class=\"line\"></div><div class=\"line\">    //获取当前数据源</div><div class=\"line\">    public static DataSourceKind getDataSource()&#123; return dataSource.get();&#125;</div><div class=\"line\">    //设置当前数据源</div><div class=\"line\">    public static void setDataSource(DataSourceKind kind)&#123; dataSource.set(kind);&#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//略过各个查询库的holder</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//继承Spring的动态数据源路由，复写获取数据源key方法</div><div class=\"line\">public class MyDynamicDataSourceRouting extends DynamicDataSourceRouting&#123;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected Object determineCurrentLookupKey() &#123;</div><div class=\"line\">        return DataSourceHolder.getDataSource();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//略过查询库的routing</div></pre></td></tr></table></figure>\n<p>具体的切换用到了SpringAOP，大致就是定义一个@DbReadOnly注解，然后当检测到有方法使用了该注解，就进行数据源的切换。<br>具体的业务场景中，只有很少一部分统计分析的请求会使用查询库，并且所有的@DbReadOnly注解基本上都是在Controller层。<br>第一步先切换到READ， 然后根据当前登录用户所处行政区划来进行查询库的切换，等到这个请求完成之后，再在finally中切换回默认的生产库来。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Object proceed(Proceed obj)&#123;</div><div class=\"line\">    DataSourceHolder.setDataSource(DataSourceKind.READ);</div><div class=\"line\">    User user = SessionUtils.getCurrentUser();    //获取当前登录的用户</div><div class=\"line\">    String xzqh = user.getXzqh();</div><div class=\"line\">    if(xzqh.equals(XzqhConsts.JinHua))&#123; ReadDataSourceHolder.setDataSource(ReadDataSourceKind.JinHua);&#125;</div><div class=\"line\">    else if(xzqh.equals(XzqhConsts.WenZhou)&#123; ReadDataSourceHolder.setDataSource(ReadDataSourceKind.WenZhou);&#125;)</div><div class=\"line\">    ....//略</div><div class=\"line\">    </div><div class=\"line\">    try&#123;</div><div class=\"line\">        return obj.proceed();</div><div class=\"line\">    &#125;catch(Exception e)&#123;</div><div class=\"line\">        e.printStackTrace();</div><div class=\"line\">    &#125;finally&#123;</div><div class=\"line\">        DataSourceHolder.setDataSource(DataSourceKind.WRITE);    //重置为生产库</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"分析与提示\"><a href=\"#分析与提示\" class=\"headerlink\" title=\"分析与提示\"></a>分析与提示</h4><p>有经验的老司机大概已经看出了问题所在， 数据之所以会写入到查询库的原因实在是很可笑。<br>还没明白过来的兄弟可以先看看接下来的提示。</p>\n<p>对于这个问题，我一开始根本摸不着头脑，因为在我的理解中，就算有线程没有切换回生产库，这个线程也会因为请求结束而被结束。<br>更何况涉及到查询库的那些请求根本不涉及INSERT操作。</p>\n<p>更何况怎么可能不切换回生产库呢？finally中的代码无论如何，就算抛运行时异常，也应该是会执行的啊？</p>\n<p>难道一个线程会被多个请求同时使用？或者ThreadLocal并不是真正的ThreadLocal?而是会在线程之间互相影响？</p>\n<p>最后绝望的我甚至还开始怀疑起枚举类是否是线程安全的。</p>\n<p>我也是被问题迷糊了头脑，实际上这个问题非常简单，我不过是在一堆错误的前提下做着无望的挣扎，而没有去怀疑自己所坚信的这些前提是否是成立的。</p>\n<p>我觉得当遇到一个看似匪夷所思，甚至毫无可能发生的异常时，需要有清醒的头脑，来反过来质疑看似坚固的前提。</p>\n<p>下面是两个小小的提示：</p>\n<ul>\n<li>线程真的会因为请求结束而结束吗？</li>\n<li>上面finally的代码真的必然后执行吗？</li>\n</ul>\n<h4 id=\"柳暗花明\"><a href=\"#柳暗花明\" class=\"headerlink\" title=\"柳暗花明\"></a>柳暗花明</h4><p>很遗憾，对于上面两个问题的答案，其实都是否定的。</p>\n<p>事实上，Tomcat存在一个线程池机制，对于完成了请求的线程，并不会立即释放，而是回收到线程池中；并且，很关键的一点是，tomcat并不会清空ThreadLocal变量。</p>\n<p>第二个问题，非常可笑的，虽然finally的确必然会执行，然而这是有条件的：如果程序在try代码块之外抛了异常，那么finally将不会被执行。</p>\n<p>至此，一切谜题的答案已经展现在眼前。</p>\n<p>用户的session丢失，会导致获取xzqh那一行代码抛空指针异常，然而之前已经切换为READ库，所以当前线程已经指向了查询库，又因为抛运行时异常，所以请求结束；<br>接着，线程被回收，进入线程池；过了不知道多久，有一个倒霉的请求被分配到了这个线程上执行，然后因为数据源并不会切换到WRITE中，所以INSERT操作会进入到查询库。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>看似不可思议的问题， 既然真真切切的发生了，那么必然又一个合乎逻辑的解释；看似不可思议，不过是因为你误解了某些前提。<br>另外我这么久也没看出问题所在，仅仅是以为我基础不够，否则如果我早知道tomcat有这么玄妙的线程池机制，那么我应该很快就能想到问题的关键点所在。</p>\n<p>不过，总的来说，这是一场很有趣的解谜体验。：）</p>\n"},{"title":"2016-12-27 日志","date":"2016-12-27T11:59:07.000Z","_content":"感觉自己真是脆弱。\n何时能变得心灵强大起来呢？为什经历一点点的挫折就开始怀疑起周围的一切呢？\n果然我需要佛学的慰藉，不断磨砺心性，以便自己能够豁达地面对各种遭遇吧。\n\n电信定位的问题解决了，然而并没有问什么原因，这可能会成为不解之谜了。\n\n感觉工作效率低，总是忍不住去浏览一些新的技术，老是妄想自己以后有技术了会多么多么富有；然而却做的很少。\n比如想要写一个秒级的端口扫描器，基于python实现；一开始定的方案是协程+asyncio框架，然而后者看了半天依旧费解。光是一个yeild就让我寻思半天依旧不得其门而入。\n\n而且感觉最近几天身体状况都不太好，因为天气原因好几天没去跑步了。\n内啡肽不够，整个人又开始变得很悲观。\n书什么的也都看不进去，翻了一半的安娜卡列尼娜好久都没动了。\n对未来不报希望，不知道将来的生活有何值得期待之处。\n真是令人伤感。\n\n杭州的天气开始变得很冷很冷，晚上就算穿着两条裤子都觉得关节有点疼。空调开不了制暖，感觉这个冬天不好过。\n明年争取多赚点钱，然后租一个小套间，能做饭的那种，然后再谈一个女朋友；这样我的生活就能慢慢步入正规。\n感觉我的问题就是缺乏自信。\n当然也可能不完全对，我最缺乏的是活着的欲望，感觉一直都是随遇而安，并没有主动地想要去追求什么东西。这大概是童年的挫折养成的一种“习得性无助”吧。\n从现在开始，改变自己。\n\n说的倒是容易，改变自己。\n世间最为困难的莫过于此。\n我想起异域的那句名言：\n> what can change the nature of a man?\n\n衰老而臃肿的解谜者彷徨在贫民巷，等待着无名者一次又一次的到来，而每次造访，后者——她的爱人，身上的伤痕越来越多，并且失去的记忆也越来越多。\n最终，她所期待的只是解脱而已。\n\n愈发感觉异域的世界观和故事情节很和我的胃口，然而那庞大的文字量和游戏时间已经让我无法再次完成体会。\n或许再过一段时间，我能静下心来，去再次体会那孤独、绝望最后却伴随救赎的史诗吧。\n\n我期待着那一天。\n","source":"_posts/2016-12-27-日志.md","raw":"---\ntitle: 2016-12-27 日志\ndate: 2016-12-27 19:59:07\ntags:\n- 日志\ncategory:\n- 日志\n---\n感觉自己真是脆弱。\n何时能变得心灵强大起来呢？为什经历一点点的挫折就开始怀疑起周围的一切呢？\n果然我需要佛学的慰藉，不断磨砺心性，以便自己能够豁达地面对各种遭遇吧。\n\n电信定位的问题解决了，然而并没有问什么原因，这可能会成为不解之谜了。\n\n感觉工作效率低，总是忍不住去浏览一些新的技术，老是妄想自己以后有技术了会多么多么富有；然而却做的很少。\n比如想要写一个秒级的端口扫描器，基于python实现；一开始定的方案是协程+asyncio框架，然而后者看了半天依旧费解。光是一个yeild就让我寻思半天依旧不得其门而入。\n\n而且感觉最近几天身体状况都不太好，因为天气原因好几天没去跑步了。\n内啡肽不够，整个人又开始变得很悲观。\n书什么的也都看不进去，翻了一半的安娜卡列尼娜好久都没动了。\n对未来不报希望，不知道将来的生活有何值得期待之处。\n真是令人伤感。\n\n杭州的天气开始变得很冷很冷，晚上就算穿着两条裤子都觉得关节有点疼。空调开不了制暖，感觉这个冬天不好过。\n明年争取多赚点钱，然后租一个小套间，能做饭的那种，然后再谈一个女朋友；这样我的生活就能慢慢步入正规。\n感觉我的问题就是缺乏自信。\n当然也可能不完全对，我最缺乏的是活着的欲望，感觉一直都是随遇而安，并没有主动地想要去追求什么东西。这大概是童年的挫折养成的一种“习得性无助”吧。\n从现在开始，改变自己。\n\n说的倒是容易，改变自己。\n世间最为困难的莫过于此。\n我想起异域的那句名言：\n> what can change the nature of a man?\n\n衰老而臃肿的解谜者彷徨在贫民巷，等待着无名者一次又一次的到来，而每次造访，后者——她的爱人，身上的伤痕越来越多，并且失去的记忆也越来越多。\n最终，她所期待的只是解脱而已。\n\n愈发感觉异域的世界观和故事情节很和我的胃口，然而那庞大的文字量和游戏时间已经让我无法再次完成体会。\n或许再过一段时间，我能静下心来，去再次体会那孤独、绝望最后却伴随救赎的史诗吧。\n\n我期待着那一天。\n","slug":"2016-12-27-日志","published":1,"updated":"2017-01-23T14:35:55.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciybhnba10007e4ttz48ffrcv","content":"<p>感觉自己真是脆弱。<br>何时能变得心灵强大起来呢？为什经历一点点的挫折就开始怀疑起周围的一切呢？<br>果然我需要佛学的慰藉，不断磨砺心性，以便自己能够豁达地面对各种遭遇吧。</p>\n<p>电信定位的问题解决了，然而并没有问什么原因，这可能会成为不解之谜了。</p>\n<p>感觉工作效率低，总是忍不住去浏览一些新的技术，老是妄想自己以后有技术了会多么多么富有；然而却做的很少。<br>比如想要写一个秒级的端口扫描器，基于python实现；一开始定的方案是协程+asyncio框架，然而后者看了半天依旧费解。光是一个yeild就让我寻思半天依旧不得其门而入。</p>\n<p>而且感觉最近几天身体状况都不太好，因为天气原因好几天没去跑步了。<br>内啡肽不够，整个人又开始变得很悲观。<br>书什么的也都看不进去，翻了一半的安娜卡列尼娜好久都没动了。<br>对未来不报希望，不知道将来的生活有何值得期待之处。<br>真是令人伤感。</p>\n<p>杭州的天气开始变得很冷很冷，晚上就算穿着两条裤子都觉得关节有点疼。空调开不了制暖，感觉这个冬天不好过。<br>明年争取多赚点钱，然后租一个小套间，能做饭的那种，然后再谈一个女朋友；这样我的生活就能慢慢步入正规。<br>感觉我的问题就是缺乏自信。<br>当然也可能不完全对，我最缺乏的是活着的欲望，感觉一直都是随遇而安，并没有主动地想要去追求什么东西。这大概是童年的挫折养成的一种“习得性无助”吧。<br>从现在开始，改变自己。</p>\n<p>说的倒是容易，改变自己。<br>世间最为困难的莫过于此。<br>我想起异域的那句名言：</p>\n<blockquote>\n<p>what can change the nature of a man?</p>\n</blockquote>\n<p>衰老而臃肿的解谜者彷徨在贫民巷，等待着无名者一次又一次的到来，而每次造访，后者——她的爱人，身上的伤痕越来越多，并且失去的记忆也越来越多。<br>最终，她所期待的只是解脱而已。</p>\n<p>愈发感觉异域的世界观和故事情节很和我的胃口，然而那庞大的文字量和游戏时间已经让我无法再次完成体会。<br>或许再过一段时间，我能静下心来，去再次体会那孤独、绝望最后却伴随救赎的史诗吧。</p>\n<p>我期待着那一天。</p>\n","excerpt":"","more":"<p>感觉自己真是脆弱。<br>何时能变得心灵强大起来呢？为什经历一点点的挫折就开始怀疑起周围的一切呢？<br>果然我需要佛学的慰藉，不断磨砺心性，以便自己能够豁达地面对各种遭遇吧。</p>\n<p>电信定位的问题解决了，然而并没有问什么原因，这可能会成为不解之谜了。</p>\n<p>感觉工作效率低，总是忍不住去浏览一些新的技术，老是妄想自己以后有技术了会多么多么富有；然而却做的很少。<br>比如想要写一个秒级的端口扫描器，基于python实现；一开始定的方案是协程+asyncio框架，然而后者看了半天依旧费解。光是一个yeild就让我寻思半天依旧不得其门而入。</p>\n<p>而且感觉最近几天身体状况都不太好，因为天气原因好几天没去跑步了。<br>内啡肽不够，整个人又开始变得很悲观。<br>书什么的也都看不进去，翻了一半的安娜卡列尼娜好久都没动了。<br>对未来不报希望，不知道将来的生活有何值得期待之处。<br>真是令人伤感。</p>\n<p>杭州的天气开始变得很冷很冷，晚上就算穿着两条裤子都觉得关节有点疼。空调开不了制暖，感觉这个冬天不好过。<br>明年争取多赚点钱，然后租一个小套间，能做饭的那种，然后再谈一个女朋友；这样我的生活就能慢慢步入正规。<br>感觉我的问题就是缺乏自信。<br>当然也可能不完全对，我最缺乏的是活着的欲望，感觉一直都是随遇而安，并没有主动地想要去追求什么东西。这大概是童年的挫折养成的一种“习得性无助”吧。<br>从现在开始，改变自己。</p>\n<p>说的倒是容易，改变自己。<br>世间最为困难的莫过于此。<br>我想起异域的那句名言：</p>\n<blockquote>\n<p>what can change the nature of a man?</p>\n</blockquote>\n<p>衰老而臃肿的解谜者彷徨在贫民巷，等待着无名者一次又一次的到来，而每次造访，后者——她的爱人，身上的伤痕越来越多，并且失去的记忆也越来越多。<br>最终，她所期待的只是解脱而已。</p>\n<p>愈发感觉异域的世界观和故事情节很和我的胃口，然而那庞大的文字量和游戏时间已经让我无法再次完成体会。<br>或许再过一段时间，我能静下心来，去再次体会那孤独、绝望最后却伴随救赎的史诗吧。</p>\n<p>我期待着那一天。</p>\n"},{"title":"2017-01-01 日志","date":"2017-01-01T02:29:16.000Z","_content":"新的一年开始了。\n\n也好几天没写日志了。\n\n几天前纠结的事情已经解决了，心境又开始变得轻松起来。\n","source":"_posts/2017-01-01-日志.md","raw":"---\ntitle: 2017-01-01 日志\ndate: 2017-01-01 10:29:16\ntags:\n- 日志\ncategory:\n- 日志\n---\n新的一年开始了。\n\n也好几天没写日志了。\n\n几天前纠结的事情已经解决了，心境又开始变得轻松起来。\n","slug":"2017-01-01-日志","published":1,"updated":"2017-01-23T14:35:55.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciybhnba40008e4ttrx9o8nkl","content":"<p>新的一年开始了。</p>\n<p>也好几天没写日志了。</p>\n<p>几天前纠结的事情已经解决了，心境又开始变得轻松起来。</p>\n","excerpt":"","more":"<p>新的一年开始了。</p>\n<p>也好几天没写日志了。</p>\n<p>几天前纠结的事情已经解决了，心境又开始变得轻松起来。</p>\n"},{"title":"TOMCAT假死分析","date":"2017-01-05T12:29:14.000Z","_content":"#### 现象\n+ tomcat假死，无法响应任何请求。\n+ CPU、内存等均无告警，假死之后CPU占用率变得很低。\n+ 无任何异常日志，CLOSE_WATI数正常。\n+ 静态资源也无法访问\n+ 通过命令查看线程数\n\n```\nps -ef|grep tomcat --获取进程ID\nps -T -p <pid>|wc -l -- 获取tomcat下线程数\n```\n\n发现有近1500个线程，这已经到达tomcat线程上限。\n\n#### 获取DUMP日志\n因为生产环境没有装JDK，只有JRE环境，费了好一番功夫才发现有个神奇的命令.\n\n```\nkill -3 <pid>\n```\n\n这个命令并不会导致进程被杀，并且会将相应的线程堆栈信息和大致的内存占用情况输出到tomcat目录下的catalina.out文件中。\n因为这个文件往往较大，所以DUMP前可以先清空这个日志文件。\n\n```\necho \"\">catalina.out -- 这个命令也可以用于运行时释放日志\n```\n\n拿到DUMP后，问题开始明朗起来：\n\n```\n\"http-bio-443-exec-1151\" daemon prio=10 tid=0x00007fd1c96c9000 nid=0x26cb in Object.wait() [0x00007fd0f914e000]\n   java.lang.Thread.State: WAITING (on object monitor)\n    at java.lang.Object.wait(Native Method)\n        - waiting on <0x00000007f5b040f8> (a org.apache.commons.pool.impl.GenericObjectPool$Latch)\n            at java.lang.Object.wait(Object.java:503)\n                at org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1118)\n                    - locked <0x00000007f5b040f8> (a org.apache.commons.pool.impl.GenericObjectPool$Latch)\n                        at org.apache.commons.dbcp.PoolingDataSource.getConnection(PoolingDataSource.java:106)\n                            at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044)\n                                at org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.getConnection(AbstractRoutingDataSource.java:164)\n                                    at org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:205)\n                                        at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:373)\n                                            at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:420)\n                                                at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:257)\n                                                    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95)\n                                                        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n                                                            at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:646)\n\n\n```\n\n有近千个线程处于WAITING状态，都是卡在获取数据库连接这一步上。\n反查数据库中的连接数:\n\n```\nSELECT COUNT(1) FROM GV$SESSION WHERE machine = '主机名'\n```\n\n结果为100，并且这些连接全部处于INACTIVE状态，而数据库连接池配置的maxActive数就是100个。\n说明数据库连接池泄露了。\n\n#### 分析\n应用框架采用的是spring+mybatis+dbcp1.4。\n由于并不需要手动关闭数据库连接，所以业务代码导致这个问题的可能性不大。\ngoogle之后发现dbcp官方JIRA上也report了这个问题，据说是一个BUG，升级到1.5.3版本能解决这个问题。\n但是奇怪的是，应用已经正常运行两年多了，为什么最近才出现这个问题呢？\n难道是因为割接的地市越来越多，导致服务器压力增大，进而导致这个问题的发生？\n如果是DBCP的BUG，那么升级版本或者替换为C3P0应该能够解决这个问题。\n但我不确定是否真的是这个原因，或许业务代码在某种极为巧合的情形下的确会导致连接无法正常关闭；那么鲁莽的行为只会掩盖这个问题，并且在日后造成更大的麻烦。\n所以最好的解决方式是找到连接泄漏的位置。\n通过采用DBCP配置：\n\n```\nmaxWait=5000\nremoveAbandoned=true\nremoveAbandonedTimeout=60\nlogAbandoned=true\n```\n\n来定位问题代码的位置。\n设置的具体含义在官方文档上有，简言之，这样设置之后，在一定条件下，会触发DBCP的回收机制。当一个连接超过一定时间没有被使用，那么就视为abandoned连接，删除之，并记录下该连接的上下文和调用栈。\n\n#### 继续跟踪\n目前连接数还没有到达指标处，继续跟踪，希望明天就能解决这个问题。\n\n\n\n\n","source":"_posts/TOMCAT假死分析.md","raw":"---\ntitle: TOMCAT假死分析\ndate: 2017-01-05 20:29:14\ntags:\n- tomcat\n- dbcp\ncategory:\n- CODE\n---\n#### 现象\n+ tomcat假死，无法响应任何请求。\n+ CPU、内存等均无告警，假死之后CPU占用率变得很低。\n+ 无任何异常日志，CLOSE_WATI数正常。\n+ 静态资源也无法访问\n+ 通过命令查看线程数\n\n```\nps -ef|grep tomcat --获取进程ID\nps -T -p <pid>|wc -l -- 获取tomcat下线程数\n```\n\n发现有近1500个线程，这已经到达tomcat线程上限。\n\n#### 获取DUMP日志\n因为生产环境没有装JDK，只有JRE环境，费了好一番功夫才发现有个神奇的命令.\n\n```\nkill -3 <pid>\n```\n\n这个命令并不会导致进程被杀，并且会将相应的线程堆栈信息和大致的内存占用情况输出到tomcat目录下的catalina.out文件中。\n因为这个文件往往较大，所以DUMP前可以先清空这个日志文件。\n\n```\necho \"\">catalina.out -- 这个命令也可以用于运行时释放日志\n```\n\n拿到DUMP后，问题开始明朗起来：\n\n```\n\"http-bio-443-exec-1151\" daemon prio=10 tid=0x00007fd1c96c9000 nid=0x26cb in Object.wait() [0x00007fd0f914e000]\n   java.lang.Thread.State: WAITING (on object monitor)\n    at java.lang.Object.wait(Native Method)\n        - waiting on <0x00000007f5b040f8> (a org.apache.commons.pool.impl.GenericObjectPool$Latch)\n            at java.lang.Object.wait(Object.java:503)\n                at org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1118)\n                    - locked <0x00000007f5b040f8> (a org.apache.commons.pool.impl.GenericObjectPool$Latch)\n                        at org.apache.commons.dbcp.PoolingDataSource.getConnection(PoolingDataSource.java:106)\n                            at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044)\n                                at org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.getConnection(AbstractRoutingDataSource.java:164)\n                                    at org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:205)\n                                        at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:373)\n                                            at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:420)\n                                                at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:257)\n                                                    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95)\n                                                        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)\n                                                            at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:646)\n\n\n```\n\n有近千个线程处于WAITING状态，都是卡在获取数据库连接这一步上。\n反查数据库中的连接数:\n\n```\nSELECT COUNT(1) FROM GV$SESSION WHERE machine = '主机名'\n```\n\n结果为100，并且这些连接全部处于INACTIVE状态，而数据库连接池配置的maxActive数就是100个。\n说明数据库连接池泄露了。\n\n#### 分析\n应用框架采用的是spring+mybatis+dbcp1.4。\n由于并不需要手动关闭数据库连接，所以业务代码导致这个问题的可能性不大。\ngoogle之后发现dbcp官方JIRA上也report了这个问题，据说是一个BUG，升级到1.5.3版本能解决这个问题。\n但是奇怪的是，应用已经正常运行两年多了，为什么最近才出现这个问题呢？\n难道是因为割接的地市越来越多，导致服务器压力增大，进而导致这个问题的发生？\n如果是DBCP的BUG，那么升级版本或者替换为C3P0应该能够解决这个问题。\n但我不确定是否真的是这个原因，或许业务代码在某种极为巧合的情形下的确会导致连接无法正常关闭；那么鲁莽的行为只会掩盖这个问题，并且在日后造成更大的麻烦。\n所以最好的解决方式是找到连接泄漏的位置。\n通过采用DBCP配置：\n\n```\nmaxWait=5000\nremoveAbandoned=true\nremoveAbandonedTimeout=60\nlogAbandoned=true\n```\n\n来定位问题代码的位置。\n设置的具体含义在官方文档上有，简言之，这样设置之后，在一定条件下，会触发DBCP的回收机制。当一个连接超过一定时间没有被使用，那么就视为abandoned连接，删除之，并记录下该连接的上下文和调用栈。\n\n#### 继续跟踪\n目前连接数还没有到达指标处，继续跟踪，希望明天就能解决这个问题。\n\n\n\n\n","slug":"TOMCAT假死分析","published":1,"updated":"2017-01-23T14:35:55.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciybhnba8000ae4tti4w66ect","content":"<h4 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h4><ul>\n<li>tomcat假死，无法响应任何请求。</li>\n<li>CPU、内存等均无告警，假死之后CPU占用率变得很低。</li>\n<li>无任何异常日志，CLOSE_WATI数正常。</li>\n<li>静态资源也无法访问</li>\n<li>通过命令查看线程数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ps -ef|grep tomcat --获取进程ID</div><div class=\"line\">ps -T -p &lt;pid&gt;|wc -l -- 获取tomcat下线程数</div></pre></td></tr></table></figure>\n<p>发现有近1500个线程，这已经到达tomcat线程上限。</p>\n<h4 id=\"获取DUMP日志\"><a href=\"#获取DUMP日志\" class=\"headerlink\" title=\"获取DUMP日志\"></a>获取DUMP日志</h4><p>因为生产环境没有装JDK，只有JRE环境，费了好一番功夫才发现有个神奇的命令.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kill -3 &lt;pid&gt;</div></pre></td></tr></table></figure>\n<p>这个命令并不会导致进程被杀，并且会将相应的线程堆栈信息和大致的内存占用情况输出到tomcat目录下的catalina.out文件中。<br>因为这个文件往往较大，所以DUMP前可以先清空这个日志文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo &quot;&quot;&gt;catalina.out -- 这个命令也可以用于运行时释放日志</div></pre></td></tr></table></figure>\n<p>拿到DUMP后，问题开始明朗起来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;http-bio-443-exec-1151&quot; daemon prio=10 tid=0x00007fd1c96c9000 nid=0x26cb in Object.wait() [0x00007fd0f914e000]</div><div class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</div><div class=\"line\">    at java.lang.Object.wait(Native Method)</div><div class=\"line\">        - waiting on &lt;0x00000007f5b040f8&gt; (a org.apache.commons.pool.impl.GenericObjectPool$Latch)</div><div class=\"line\">            at java.lang.Object.wait(Object.java:503)</div><div class=\"line\">                at org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1118)</div><div class=\"line\">                    - locked &lt;0x00000007f5b040f8&gt; (a org.apache.commons.pool.impl.GenericObjectPool$Latch)</div><div class=\"line\">                        at org.apache.commons.dbcp.PoolingDataSource.getConnection(PoolingDataSource.java:106)</div><div class=\"line\">                            at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044)</div><div class=\"line\">                                at org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.getConnection(AbstractRoutingDataSource.java:164)</div><div class=\"line\">                                    at org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:205)</div><div class=\"line\">                                        at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:373)</div><div class=\"line\">                                            at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:420)</div><div class=\"line\">                                                at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:257)</div><div class=\"line\">                                                    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95)</div><div class=\"line\">                                                        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</div><div class=\"line\">                                                            at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:646)</div></pre></td></tr></table></figure>\n<p>有近千个线程处于WAITING状态，都是卡在获取数据库连接这一步上。<br>反查数据库中的连接数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT COUNT(1) FROM GV$SESSION WHERE machine = &apos;主机名&apos;</div></pre></td></tr></table></figure>\n<p>结果为100，并且这些连接全部处于INACTIVE状态，而数据库连接池配置的maxActive数就是100个。<br>说明数据库连接池泄露了。</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>应用框架采用的是spring+mybatis+dbcp1.4。<br>由于并不需要手动关闭数据库连接，所以业务代码导致这个问题的可能性不大。<br>google之后发现dbcp官方JIRA上也report了这个问题，据说是一个BUG，升级到1.5.3版本能解决这个问题。<br>但是奇怪的是，应用已经正常运行两年多了，为什么最近才出现这个问题呢？<br>难道是因为割接的地市越来越多，导致服务器压力增大，进而导致这个问题的发生？<br>如果是DBCP的BUG，那么升级版本或者替换为C3P0应该能够解决这个问题。<br>但我不确定是否真的是这个原因，或许业务代码在某种极为巧合的情形下的确会导致连接无法正常关闭；那么鲁莽的行为只会掩盖这个问题，并且在日后造成更大的麻烦。<br>所以最好的解决方式是找到连接泄漏的位置。<br>通过采用DBCP配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">maxWait=5000</div><div class=\"line\">removeAbandoned=true</div><div class=\"line\">removeAbandonedTimeout=60</div><div class=\"line\">logAbandoned=true</div></pre></td></tr></table></figure>\n<p>来定位问题代码的位置。<br>设置的具体含义在官方文档上有，简言之，这样设置之后，在一定条件下，会触发DBCP的回收机制。当一个连接超过一定时间没有被使用，那么就视为abandoned连接，删除之，并记录下该连接的上下文和调用栈。</p>\n<h4 id=\"继续跟踪\"><a href=\"#继续跟踪\" class=\"headerlink\" title=\"继续跟踪\"></a>继续跟踪</h4><p>目前连接数还没有到达指标处，继续跟踪，希望明天就能解决这个问题。</p>\n","excerpt":"","more":"<h4 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h4><ul>\n<li>tomcat假死，无法响应任何请求。</li>\n<li>CPU、内存等均无告警，假死之后CPU占用率变得很低。</li>\n<li>无任何异常日志，CLOSE_WATI数正常。</li>\n<li>静态资源也无法访问</li>\n<li>通过命令查看线程数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">ps -ef|grep tomcat --获取进程ID</div><div class=\"line\">ps -T -p &lt;pid&gt;|wc -l -- 获取tomcat下线程数</div></pre></td></tr></table></figure>\n<p>发现有近1500个线程，这已经到达tomcat线程上限。</p>\n<h4 id=\"获取DUMP日志\"><a href=\"#获取DUMP日志\" class=\"headerlink\" title=\"获取DUMP日志\"></a>获取DUMP日志</h4><p>因为生产环境没有装JDK，只有JRE环境，费了好一番功夫才发现有个神奇的命令.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">kill -3 &lt;pid&gt;</div></pre></td></tr></table></figure>\n<p>这个命令并不会导致进程被杀，并且会将相应的线程堆栈信息和大致的内存占用情况输出到tomcat目录下的catalina.out文件中。<br>因为这个文件往往较大，所以DUMP前可以先清空这个日志文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">echo &quot;&quot;&gt;catalina.out -- 这个命令也可以用于运行时释放日志</div></pre></td></tr></table></figure>\n<p>拿到DUMP后，问题开始明朗起来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;http-bio-443-exec-1151&quot; daemon prio=10 tid=0x00007fd1c96c9000 nid=0x26cb in Object.wait() [0x00007fd0f914e000]</div><div class=\"line\">   java.lang.Thread.State: WAITING (on object monitor)</div><div class=\"line\">    at java.lang.Object.wait(Native Method)</div><div class=\"line\">        - waiting on &lt;0x00000007f5b040f8&gt; (a org.apache.commons.pool.impl.GenericObjectPool$Latch)</div><div class=\"line\">            at java.lang.Object.wait(Object.java:503)</div><div class=\"line\">                at org.apache.commons.pool.impl.GenericObjectPool.borrowObject(GenericObjectPool.java:1118)</div><div class=\"line\">                    - locked &lt;0x00000007f5b040f8&gt; (a org.apache.commons.pool.impl.GenericObjectPool$Latch)</div><div class=\"line\">                        at org.apache.commons.dbcp.PoolingDataSource.getConnection(PoolingDataSource.java:106)</div><div class=\"line\">                            at org.apache.commons.dbcp.BasicDataSource.getConnection(BasicDataSource.java:1044)</div><div class=\"line\">                                at org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.getConnection(AbstractRoutingDataSource.java:164)</div><div class=\"line\">                                    at org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin(DataSourceTransactionManager.java:205)</div><div class=\"line\">                                        at org.springframework.transaction.support.AbstractPlatformTransactionManager.getTransaction(AbstractPlatformTransactionManager.java:373)</div><div class=\"line\">                                            at org.springframework.transaction.interceptor.TransactionAspectSupport.createTransactionIfNecessary(TransactionAspectSupport.java:420)</div><div class=\"line\">                                                at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:257)</div><div class=\"line\">                                                    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:95)</div><div class=\"line\">                                                        at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:179)</div><div class=\"line\">                                                            at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:646)</div></pre></td></tr></table></figure>\n<p>有近千个线程处于WAITING状态，都是卡在获取数据库连接这一步上。<br>反查数据库中的连接数:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SELECT COUNT(1) FROM GV$SESSION WHERE machine = &apos;主机名&apos;</div></pre></td></tr></table></figure>\n<p>结果为100，并且这些连接全部处于INACTIVE状态，而数据库连接池配置的maxActive数就是100个。<br>说明数据库连接池泄露了。</p>\n<h4 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h4><p>应用框架采用的是spring+mybatis+dbcp1.4。<br>由于并不需要手动关闭数据库连接，所以业务代码导致这个问题的可能性不大。<br>google之后发现dbcp官方JIRA上也report了这个问题，据说是一个BUG，升级到1.5.3版本能解决这个问题。<br>但是奇怪的是，应用已经正常运行两年多了，为什么最近才出现这个问题呢？<br>难道是因为割接的地市越来越多，导致服务器压力增大，进而导致这个问题的发生？<br>如果是DBCP的BUG，那么升级版本或者替换为C3P0应该能够解决这个问题。<br>但我不确定是否真的是这个原因，或许业务代码在某种极为巧合的情形下的确会导致连接无法正常关闭；那么鲁莽的行为只会掩盖这个问题，并且在日后造成更大的麻烦。<br>所以最好的解决方式是找到连接泄漏的位置。<br>通过采用DBCP配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">maxWait=5000</div><div class=\"line\">removeAbandoned=true</div><div class=\"line\">removeAbandonedTimeout=60</div><div class=\"line\">logAbandoned=true</div></pre></td></tr></table></figure>\n<p>来定位问题代码的位置。<br>设置的具体含义在官方文档上有，简言之，这样设置之后，在一定条件下，会触发DBCP的回收机制。当一个连接超过一定时间没有被使用，那么就视为abandoned连接，删除之，并记录下该连接的上下文和调用栈。</p>\n<h4 id=\"继续跟踪\"><a href=\"#继续跟踪\" class=\"headerlink\" title=\"继续跟踪\"></a>继续跟踪</h4><p>目前连接数还没有到达指标处，继续跟踪，希望明天就能解决这个问题。</p>\n"},{"title":"hexo+ubuntu+github博客环境搭建","date":"2016-12-26T15:28:05.000Z","_content":"总算把环境给搭好了。\n架构为：hexo+github，系统为ubuntu。\n\n### 源代码管理\n首先在github创建一个仓库，建立两个分支：master，gh-pages。\nmaster用来存放源代码，gh-pages用来存放编译后的html静态页面文件。\n前者手动管理，后者配置在conf中由hexo进行管理。\n+ 创建文件夹\n```\nmkdir repository\ncd repository\n```\n\n+ 建立git环境\n```\ngit clone https://github.com/LiangKim/myblog.git\n```\n这样在repository文件夹下就自动多了myblog文件夹。\n此时该文件夹应该是空的，如果不是也可以把其中无用文件删了然后提交.\n\n### hexo\n+ 建立hexo环境\n进行到此步时，默认已经安装好了nodejs，npm等依赖。如有不懂可以google之。\n要注意的是，在ubuntu环境下，安装nodejs最好通过编译源代码安装。apt的方式总会出莫名其妙的问题。\n```\nsudo npm install hexo -g\nnpm install hexo-deployer-git --save\n```\n第一行命令安装hexo环境，第二行命令安装了git插件。\n进入myblog目录:\n```\nhexo init\n```\n这一步代码执行了\n","source":"_posts/博客环境搭建.md","raw":"---\ntitle: hexo+ubuntu+github博客环境搭建\ndate: 2016-12-26 23:28:05\ntags:\n- hexo\n- ubuntu\n- shadowsocks\ncategory:\n- 通用技术\n---\n总算把环境给搭好了。\n架构为：hexo+github，系统为ubuntu。\n\n### 源代码管理\n首先在github创建一个仓库，建立两个分支：master，gh-pages。\nmaster用来存放源代码，gh-pages用来存放编译后的html静态页面文件。\n前者手动管理，后者配置在conf中由hexo进行管理。\n+ 创建文件夹\n```\nmkdir repository\ncd repository\n```\n\n+ 建立git环境\n```\ngit clone https://github.com/LiangKim/myblog.git\n```\n这样在repository文件夹下就自动多了myblog文件夹。\n此时该文件夹应该是空的，如果不是也可以把其中无用文件删了然后提交.\n\n### hexo\n+ 建立hexo环境\n进行到此步时，默认已经安装好了nodejs，npm等依赖。如有不懂可以google之。\n要注意的是，在ubuntu环境下，安装nodejs最好通过编译源代码安装。apt的方式总会出莫名其妙的问题。\n```\nsudo npm install hexo -g\nnpm install hexo-deployer-git --save\n```\n第一行命令安装hexo环境，第二行命令安装了git插件。\n进入myblog目录:\n```\nhexo init\n```\n这一步代码执行了\n","slug":"博客环境搭建","published":1,"updated":"2017-01-23T14:35:55.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciybhnbaa000ee4ttqrnok91g","content":"<p>总算把环境给搭好了。<br>架构为：hexo+github，系统为ubuntu。</p>\n<h3 id=\"源代码管理\"><a href=\"#源代码管理\" class=\"headerlink\" title=\"源代码管理\"></a>源代码管理</h3><p>首先在github创建一个仓库，建立两个分支：master，gh-pages。<br>master用来存放源代码，gh-pages用来存放编译后的html静态页面文件。<br>前者手动管理，后者配置在conf中由hexo进行管理。</p>\n<ul>\n<li><p>创建文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir repository</div><div class=\"line\">cd repository</div></pre></td></tr></table></figure>\n</li>\n<li><p>建立git环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/LiangKim/myblog.git</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样在repository文件夹下就自动多了myblog文件夹。<br>此时该文件夹应该是空的，如果不是也可以把其中无用文件删了然后提交.</p>\n<h3 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h3><ul>\n<li>建立hexo环境<br>进行到此步时，默认已经安装好了nodejs，npm等依赖。如有不懂可以google之。<br>要注意的是，在ubuntu环境下，安装nodejs最好通过编译源代码安装。apt的方式总会出莫名其妙的问题。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo npm install hexo -g</div><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>第一行命令安装hexo环境，第二行命令安装了git插件。<br>进入myblog目录:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div></pre></td></tr></table></figure></p>\n<p>这一步代码执行了</p>\n","excerpt":"","more":"<p>总算把环境给搭好了。<br>架构为：hexo+github，系统为ubuntu。</p>\n<h3 id=\"源代码管理\"><a href=\"#源代码管理\" class=\"headerlink\" title=\"源代码管理\"></a>源代码管理</h3><p>首先在github创建一个仓库，建立两个分支：master，gh-pages。<br>master用来存放源代码，gh-pages用来存放编译后的html静态页面文件。<br>前者手动管理，后者配置在conf中由hexo进行管理。</p>\n<ul>\n<li><p>创建文件夹</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir repository</div><div class=\"line\">cd repository</div></pre></td></tr></table></figure>\n</li>\n<li><p>建立git环境</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git clone https://github.com/LiangKim/myblog.git</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样在repository文件夹下就自动多了myblog文件夹。<br>此时该文件夹应该是空的，如果不是也可以把其中无用文件删了然后提交.</p>\n<h3 id=\"hexo\"><a href=\"#hexo\" class=\"headerlink\" title=\"hexo\"></a>hexo</h3><ul>\n<li>建立hexo环境<br>进行到此步时，默认已经安装好了nodejs，npm等依赖。如有不懂可以google之。<br>要注意的是，在ubuntu环境下，安装nodejs最好通过编译源代码安装。apt的方式总会出莫名其妙的问题。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo npm install hexo -g</div><div class=\"line\">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>第一行命令安装hexo环境，第二行命令安装了git插件。<br>进入myblog目录:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">hexo init</div></pre></td></tr></table></figure></p>\n<p>这一步代码执行了</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ciybhnba10007e4ttz48ffrcv","category_id":"ciybhnb9v0004e4ttd1sbedwd","_id":"ciybhnba9000de4tte11yg9b0"},{"post_id":"ciybhnb9n0000e4ttg87s70g3","category_id":"ciybhnb9v0004e4ttd1sbedwd","_id":"ciybhnbab000he4tt4apj9q0f"},{"post_id":"ciybhnba40008e4ttrx9o8nkl","category_id":"ciybhnb9v0004e4ttd1sbedwd","_id":"ciybhnbab000je4ttp4vb7i30"},{"post_id":"ciybhnb9r0002e4tt1etc5sp7","category_id":"ciybhnb9v0004e4ttd1sbedwd","_id":"ciybhnbac000le4ttx0h3fe8d"},{"post_id":"ciybhnba00005e4tt6j6gw3hn","category_id":"ciybhnbaa000fe4ttovpjzzxo","_id":"ciybhnbac000ne4tta0irm0ee"},{"post_id":"ciybhnba8000ae4tti4w66ect","category_id":"ciybhnbac000ke4ttg18lneas","_id":"ciybhnbae000qe4tt0huc5hl3"},{"post_id":"ciybhnbaa000ee4ttqrnok91g","category_id":"ciybhnbac000oe4tt1e2fc6ov","_id":"ciybhnbae000ve4ttinolbtcl"}],"PostTag":[{"post_id":"ciybhnba40008e4ttrx9o8nkl","tag_id":"ciybhnba10006e4tt8ccaykx6","_id":"ciybhnba9000ce4ttmtw12zzp"},{"post_id":"ciybhnb9r0002e4tt1etc5sp7","tag_id":"ciybhnba10006e4tt8ccaykx6","_id":"ciybhnbab000ge4tte9t1typ5"},{"post_id":"ciybhnba00005e4tt6j6gw3hn","tag_id":"ciybhnba9000be4tt5nwnbr9p","_id":"ciybhnbae000re4ttcn7pwpg9"},{"post_id":"ciybhnba00005e4tt6j6gw3hn","tag_id":"ciybhnbab000ie4ttbc7eegtq","_id":"ciybhnbae000se4ttf8zq6kjh"},{"post_id":"ciybhnba00005e4tt6j6gw3hn","tag_id":"ciybhnbac000me4ttkau92juu","_id":"ciybhnbae000ue4tts1jv6nc6"},{"post_id":"ciybhnba10007e4ttz48ffrcv","tag_id":"ciybhnba10006e4tt8ccaykx6","_id":"ciybhnbae000we4tt5klerpnk"},{"post_id":"ciybhnba8000ae4tti4w66ect","tag_id":"ciybhnbae000te4tt7rmey5kt","_id":"ciybhnbag000ze4ttviao6tad"},{"post_id":"ciybhnba8000ae4tti4w66ect","tag_id":"ciybhnbaf000xe4ttp9ssp8bu","_id":"ciybhnbag0010e4ttllm4l61j"},{"post_id":"ciybhnbaa000ee4ttqrnok91g","tag_id":"ciybhnbag000ye4ttpkqh2zyh","_id":"ciybhnbaj0013e4ttc2odc611"},{"post_id":"ciybhnbaa000ee4ttqrnok91g","tag_id":"ciybhnbag0011e4tt59o7xze4","_id":"ciybhnbal0014e4ttcxallyw1"},{"post_id":"ciybhnbaa000ee4ttqrnok91g","tag_id":"ciybhnbah0012e4ttoh5dbqvi","_id":"ciybhnbam0015e4ttxypwm4xl"}],"Tag":[{"name":"日志","_id":"ciybhnba10006e4tt8ccaykx6"},{"name":"BUG","_id":"ciybhnba9000be4tt5nwnbr9p"},{"name":"Spring","_id":"ciybhnbab000ie4ttbc7eegtq"},{"name":"DynamicDataSourceRouting","_id":"ciybhnbac000me4ttkau92juu"},{"name":"tomcat","_id":"ciybhnbae000te4tt7rmey5kt"},{"name":"dbcp","_id":"ciybhnbaf000xe4ttp9ssp8bu"},{"name":"hexo","_id":"ciybhnbag000ye4ttpkqh2zyh"},{"name":"ubuntu","_id":"ciybhnbag0011e4tt59o7xze4"},{"name":"shadowsocks","_id":"ciybhnbah0012e4ttoh5dbqvi"}]}}